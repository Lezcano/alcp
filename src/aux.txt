#ifndef __EXCEPTIONS_HPP
#define __EXCEPTIONS_HPP

#include <string>
#include <iosfwd>

/**
 * Every exception inherits from this class
 *
 * This is not needed in C++17
 */

class ExcepALCP {
public:
	ExcepALCP() {}
	ExcepALCP(const std::string &msg) : _msg(msg) {}

	const std::string msg() const { return _msg; }

	friend std::ostream &operator<<(std::ostream &out, const ExcepALCP &e);

protected:
	std::string _msg;
};

inline std::ostream &operator<<(std::ostream &out, const ExcepALCP &e) {
	out << e._msg;
	return out;
}


// Macro defined in order to not repeat
// many times the same structure
#define DECLARE_EXCEPTION(Exception) \
class Exception : public ExcepALCP { \
public: \
Exception() {} \
Exception(const std::string &msg) : ExcepALCP(msg) {} \
}

/**
 *  Thrown when a Field with a non prime p is declared
 */
DECLARE_EXCEPTION(EpNotPrime);

/**
 *  Thrown when two numbers which are not in the same field are added
 */
DECLARE_EXCEPTION(EOperationUnsupported);

/**
 *  Yet to be implemented functionality
 */
DECLARE_EXCEPTION(ENotImplementedYet);

/**
 *  Thrown when tying to create an element of Fp[X] with a vector with elemnts
 *   not in F_p (but in other Fpelem)
 *  Also thrown when trying to assing to an element in some ED another element
 *   which is not in a compatible ED (e.g. an element assign an element from F_3
 *   an element in F_5;
 */
DECLARE_EXCEPTION(ENotCompatible);

/**
 * Thrown when trying to create an element of F[X] with an empty vector
 */
DECLARE_EXCEPTION(EEmptyVector);


#endif // __EXCEPTIONS_HPP
//#include <vector>
//#include <algorithm>
//#include <utility>
//#include <random>
//#include <chrono>
//#include "fp.hpp"
//#include "fpelem.hpp"
//#include "fpxelem.hpp"
//#include "fq.hpp"
//#include "fqelem.hpp"
//#include "fqxelem.hpp"
//#include "generalPurpose.hpp"
//#include "types.hpp"
//#include <iostream> //TODO Quitar

/* Detalles de la implementación:
 * 	formMatrix:
 * 		-En la función  el for interno se recorre en sentido descendente para
 * 		poder hacer los calculos sin usar otro array.
 * 		-Se lleva un contador en el for externo que cuenta hasta q para no
 * 		tener que usar %
 * 	kernelBasis:
 * 		-El for de la linea 86 va en sentido descendente porque se necesita en
 * 		todo momento el valor mat[k][i]. De esta manera éste se actualiza
 * 		exactamente en la ultima operación.
 * 		-El for de la línea 94 debería calcular I-M pero eso es muy	caro y
 * 		nosotros sólo necesitamos una base, así que en lugar de eso, calculo
 * 		M-I que también vale como base.
 * 		- Linea 98 j=1 se hace (en vez de j=0) porque el primer elemento
 * 		de la base es siempre (1, 0,..,0), (aunque como yo cojo la
 * 		base con los números opuestos sería (-1, 0,..,0)) y no se usa
 * 		para nada así que directamente no la calculo ni añado a result
 * 		(esto hace que en berlekamp r se inicialize a 0 en vez de
 * 		a 1 y que k se inicialize a base.size()+1
 * 		-Línea 103, la fila j es nula si y solo si el elemento mat[j][j]
 * 		es cero (en caso contrario es 1)
 *  berlekamp_simple:
 *  	-Lo dicho antes sobre las inicializaciones de r y k
 *	partialFactorDD:
 *		-Resulta que para elevar (en mod pol) un polinomio a la q, lo
 *		unico que hay que hacer es multiplicar sus coeficientes por
 *		la matriz de formMatrix, así que para calcular x^{iq}-x (mod pol)
 *		lo que hago es cogerme el x^{(i-1)q} que tenía de antes, multiplico
 *		sus	coeficientes por la matriz y ya tengo x^{iq} (mod pol)
 *		-La primera iteración no la hago dentro del bucle porque x^q es la
 *		segunda fila de la matriz, así que no tengo que calcularlo.
 *		-En el result.push_back de dentro del while hago
 *		gcd(x^{qi}-x(mod pol), pol1) donde pol es el polinomio original y pol1
 *		es un divisor. En el libro hacen modulo pol1 en vez de pol, pero notese que al ser pol multiplo de pol1 se tiene que
 *		(x^{qi}-x(mod pol)) (mod pol1) = x^{qi}-x(mod pol1)
 *		así que por la propiedad del algorimo de euclides el gcd es el mismo.
 *
 *		*/

template<typename T>
using matrix = std::vector< std::vector<T> >;


template <typename Fxelem>
//Outputs a vector of pairs with the factors and multiplicities of the square free factorization (not necesarily sorted by multiplicity)
std::vector< std::pair< Fxelem, unsigned int> > squareFreeFF (const Fxelem & a) {
	int i = 1;
	Fxelem result;
	Fxelem b = a.derivative();
	if (b != 0){
		Fxelem c = gcd (a, b);
		Fxelem w = a/c;
		while (w != 1){
			Fxelem y = gcd (w, c);
			Fxelem z = w/y;
			result.push_back(make_pair< Fxelem, unsigned int >(z, i));
			i++;
			w = y;
			c = c/y;
		}
		if  (c != 1){
			big_int exponent = fastPow (a.getP(), a.getM()-1);
			//This for computes c = c^{1/p}
			for (int j = 0; j < c.deg(); ++j )
				if (c[j] != 0)
					c[j] = fastPow(c[j], exponent);
			//TODO push_back y demás
			auto aux = squareFreeFF(c);
			big_int p = c.getP();
			for (auto pair: aux){
				pair.second *= p;
			}
			result.insert(
				result.end(),
				std::make_move_iterator(aux.begin()),
				std::make_move_iterator(aux.end())
			);
		}
	}
	else{ // a is of the form: a_0 + a_p x^p + ... a_{kp} x^{kp} (because its derivative is zero)
		big_int exponent = fastPow (a.getP(), a.getM()-1);
		//This for computes a = a^{1/p}
		for (int j = 0; j < a.deg(); ++j )
			if (a[j] != 0)
				a[j] = fastPow(a[j], exponent);
		//TODO push_back y demás
		auto aux = squareFreeFF(a);
		big_int p = a.getP();
		for (auto pair: aux){
			pair.second *= p;
		}
		result.insert(
			result.end(),
			std::make_move_iterator(aux.begin()),
			std::make_move_iterator(aux.end())
		);
	}
	return result;
}


/**
 * Input: a polynomial pol over a field of size q
 * Output: Matrix Q with x^0, x^q, x^{2q},..., x^{(n-1)*q} (mod pol) as rows
 * Complexity: O(q n^2) where n is deg(pol)
 * There is a solution in O(log(q)n^2 + n^3), it is better for big q and small n
 */
template <typename Fxelem>
matrix<typename Fxelem::Felem> formMatrix (const Fxelem &pol) {
    typename Fxelem::F f = pol.getField();
	big_int q = f.getSize(); 
	int n = pol.deg();

	std::vector<typename Fxelem::Felem> r(n, f.get(0));
	r[0] = 1; //r == (1, 0, ..., 0)
	matrix<typename Fxelem::Felem> result;
	result.push_back(r);
	for (big_int i = 1; i<= (n-1)*q; ++i){ //TODO ¿está bien definida la multiplicación (n-1)*q ? (n es un int)
		// r = (-r_{n-1}*pol_0, r_0 -r_{n-1}*pol_1,..., r_{n-2}-r_{n-1}*pol_{n-1})
		auto aux = r[n-1];
		for (ll j = n-1; j >= 1; --j){
			r[j] = r[j-1]-aux*pol[j];
		}
		r[0] = -aux*pol[0];
		if ( i % q == 0)
			result.push_back(r);
	}
	return result;
}

/**
 * Input: a square matrix.
 * Output: a basis for the kernel of a matrix. The matrix is destroyed.
 *
 * It forms a lower triangular matrix L. It will satisfies that L^2 = L
 * so as (I-L)L = 0, the non zero rows of I-L form a base for the kernel
 * of the original matrix
 *
 * Complexity:
 *  O(n^3) where n is the dimension of the square matrix
 */
template <typename Fxelem>
std::vector< std::vector< typename Fxelem::Felem > > kernelBasis (matrix<typename Fxelem::Felem> & mat){
	int n = mat.size();
	int i, j;
	std::vector< std::vector< typename Fxelem::Felem > > result;

	for (int k = 0; k < n; ++k ){
		//Search for pivot element
		for (i = k; i < n && mat[(size_t)k][i] == 0 ; ++i);

		if (i<n){
			//Normalize column i
			typename Fxelem::Felem inv = mat[k][i].inv();
			for (j = 0; j < n; ++j){
				if (j==k) mat[j][i] = 1; //This is the pivot
				else if (mat[j][i] != 0) mat[j][i] *= inv;
			}
			//Interchange column i with column k
			if (i!=k){
				for (j = 0; j < n; ++j){
					std::swap(mat[j][k], mat[j][i]);
				}
			}
			i=0;
			while(i < n){
				if (i==k) {
					++i;
					continue;
				}
				for (j = n-1; j >= k ; --j){//It has to be backwards
					mat[j][i] -= mat[j][k]*mat[k][i];
				}
				++i;
			}
		}
	}
	// M = M - I; //Note this is -1*(I-M)
	for (i=0; i<n; ++i)
		mat[i][i] -= 1;

	//Return non zero rows
	j=1; //we do not need the first row
	while (j < n){
		//Look for the next non zero row
		while (true){
			if (j >=n) break;
			if (mat[j][j] == 0) ++j; //The row is zero iff mat[j][j] == 0
			else break;
		}
		if (j >= n) break;
		result.push_back(mat[j]);
		++j;
	}
	return result;

}

/* Berlekamp's algorithm
 *
 * Input: a square-free polynomial pol \in F_{p^m}[x]
 * Output: a vector with the irreducible factors of pol
 *
 * Theoretical background:
 *  The set W:={v(x) \in FX | v^q = v (mod pol)} is a vectorial space
 *   whose dimension is the number of irreducible factors of pol. If v \in W
 *   is a non constant polynomial then:
 *    pol(x) = \prod_{s \in F} gcd(v(x)-s, pol(x));
 *  So computing all those gcd where for a base {v_1 .. v_k} of W gives us
 *   the irreducible polynomials of pol
 *
 * Complexity: q is the size of the field and n the degree of pol and k
 * is the number of factors of pol (on average is log(n)):
 *  O(k q n^2 +n^3)
 *
 * */


template <typename Fxelem>
std::vector< Fxelem > berlekamp_simple (const Fxelem &pol){
	std::vector< Fxelem > factors;
	factors.push_back(pol);
	big_int r=0;
	auto mat = formMatrix(pol);
	int n = pol.deg();
	for (int i=0; i<n; ++i)
		mat[i][i] -= 1;
	auto base = kernelBasis<Fxelem>(mat);
	int k = base.size()+1;//we do not have computed the first element of the base, so have to add 1 to k
	while (factors.size() < k){
		for (int i = 0; i < factors.size(); ++i){
			Fxelem v(base[(size_t)r]);
			for(auto &s : pol.getField().getElems()){
				Fxelem g = gcd(v-s, factors[i]);
				if (g != 1 && g != factors[i]){
					factors[i]/=g; //We continue in the loop with the new factors[i] because it is a divisor of the old factors[i] so it is not necessary to check the previous s and r.
					factors.push_back(g);
					if (factors.size() == k) return factors;
				}
			}
		}
		++r;
	}
	return factors;
}

/*
//Part I
template<typename Fxelem>
std::vector< Fxelem > squareFreeFactorization (const Fxelem &pol);
 */

//Part II
/*
 *
 *
 * */
template<typename Fxelem>
std::vector< std::pair< Fxelem, unsigned int> > partialFactorDD ( Fxelem &pol){//TODO: Copiar el polinomio en vez de pasarlo por referencia??
	int n = pol.deg();
	auto mat = formMatrix(pol);

	//first iteration is performed out of the loop because we have r in mat (there is no need to compute it again)
	std::vector<typename Fxelem::Felem> r = mat[1];
	//result[i].first will be a product of irreducible polynomials with degree result[i].second
	std::vector< std::pair< Fxelem, unsigned int > > result;
	unsigned int i = 1;
	r[1] -= 1;
	result.push_back(std::make_pair(gcd(Fxelem(r), pol), i));

	r[1] += 1;
	if (result.back().first != 1)
		pol /= result.back().first;

	++i;
	while (i <= pol.deg()/2){
		std::vector<typename Fxelem::Felem> aux = r;
		for (int j = 0; j < n; ++j){
				r[j] = aux[0]*mat[0][j] ;
			for (int k = 1; k < n; ++k ){
				r[j] += aux[k]*mat[k][j];
			}
		}//This is just r = r*mat;
		r[1] -= 1;
		result.push_back(std::make_pair(gcd(Fxelem(r), pol), i+1));//gcd (a_1, w (mod a)) = gcd (a_1, w (mod a_1)) where a_1 divides a (because (w (mod a))(mod a_1) = w (mod a_1))
		r[1] += 1;
		if (result.back().first != 1)
			pol /= result.back().first;
		else
			result.pop_back();
		++i;
	}
	if (pol != 1)
		result.push_back(std::make_pair(pol, pol.deg()));

	return result;
}
template <typename Fxelem>
void fastPowModPol (Fxelem & a, big_int b, std::vector<Fxelem> pwrsX, int deg){
	if (b == 0){
		a = Fxelem (a.getField().get(1));
	}
	else{
		Fxelem aux = a;
		a = Fxelem(a.getField().get(1));
		while (b != 0){
			if (b % 2 == 0){
				aux*=aux;
				for (int i = 0; i <= (int)(aux.deg())-deg; ++i){//aux.deg is always <= 2*deg-2
					if (aux[i+deg] != 0)
						aux += Fxelem(aux[i+deg])*pwrsX[i];
				}
				b /= 2;
			}
			else{
				a *= aux;
				for (int i = 0; i <= (int)(a.deg())-deg; ++i){//a.deg is always <= 2*deg-2
					if (a[i+deg] != 0)
						a += Fxelem(a[i+deg])*pwrsX[i];
				}
				aux *= aux;
				for (int i = 0; i <= (int)(aux.deg())-deg; ++i){//aux.deg is always <= 2*deg-2
					if (aux[i+deg] != 0)
						aux += Fxelem(aux[i+deg])*pwrsX[i];
				}
				b -= 1;
			}
		}
	}
}



template <typename Fxelem >
Fxelem randomPol (const typename Fxelem::F & field, int degree){
	//TODO esto genera números aleatorios de 64, parece suficiente, pero si q es mayor que 2^63 en realidad no lo es...
	std::mt19937_64 generator(std::chrono::system_clock::now().time_since_epoch().count());
	std::vector< typename Fxelem::Felem > r;
	for (int i = 0; i<= degree; ++i){
		r.push_back(field.get(generator()));
	}
	return Fxelem(r);
}


//Part III
template<typename Fxelem>
std::vector< Fxelem > splitFactorsDD (const Fxelem &pol, int n){
	int polDeg = pol.deg();
	if (polDeg <= n){
		std::vector< Fxelem > factors;
		factors.push_back(pol);
		return factors;
	}
	int m = polDeg/n;

	std::vector < Fxelem > pwrsX;
 	std::vector<typename Fxelem::Felem> r(2*polDeg-1, pol.getField().get(0));
	r[polDeg-1] = 1; //r == (0, 0, ..., 1)
	for (int i = polDeg; i<= 2*polDeg-2; ++i){
		// r = (-r_{n-1}*pol_0, r_0 -r_{n-1}*pol_1,..., r_{n-2}-r_{n-1}*pol_{n-1})
		auto aux = r[polDeg-1];
		for (ll j = polDeg-1; j >= 1; --j){
			r[j] = r[j-1]-aux*pol[j];
		}
		r[0] = -aux*pol[0];
		r[i] = -1;
		pwrsX.push_back(Fxelem(r));
		r[i] = 0;
	}

	while (true){
		Fxelem v = randomPol<Fxelem>(pol.getField(), 2*n-1);
		if (pol.getField().getSize() % 2 == 0){//size %2 == 0 iff p %2 == 0
			Fxelem aux = v;
			for (int i = 1; i<= n*m-1; ++i){
				aux*=aux;
				//This loop performs the operation (mod pol)
				for (int i = polDeg; i <= aux.deg(); ++i){//aux.deg is always <= 2*polDeg-2
					if (aux[i] != 0)
						aux += Fxelem(aux[i])*pwrsX[i-polDeg];
				}
				v += aux;
			}
		}
		else{
			fastPowModPol<Fxelem> (v, (fastPow(pol.getField().getSize(), n) -1)/2, pwrsX, pol.deg());
			v -= pol.getField().get(1);
		}
		Fxelem g = gcd (pol, v);
		if (g != 1 && g != pol){
			std::vector< Fxelem > factors = splitFactorsDD(g, n);
			std::vector< Fxelem > factors2 = splitFactorsDD(pol/g, n);
			factors.insert(
				factors.end(),
				std::make_move_iterator(factors2.begin()),
				std::make_move_iterator(factors2.end())
			);
			return factors;
		}
	}
}
/*
template std::vector< Fxelem > splitFactorsDD (const Fxelem &pol);
template std::vector< Fxelem > partialFactorDD (const Fxelem &pol);

*/
template std::vector< std::pair< Fpxelem, unsigned int> > squareFreeFF (const Fpxelem & a);
template std::vector< std::pair< Fpxelem, unsigned int> > partialFactorDD ( Fpxelem &pol);
template std::vector< Fpxelem > splitFactorsDD (const Fpxelem &pol, int n);
template Fpxelem randomPol (const typename Fpxelem::F &field, int degree);
template std::vector< Fpxelem > berlekamp_simple (const Fpxelem &pol);

template std::vector< std::pair< Fqxelem, unsigned int> > squareFreeFF (const Fqxelem & a);
template std::vector< std::pair< Fqxelem, unsigned int> > partialFactorDD ( Fqxelem &pol);
template std::vector< Fqxelem > splitFactorsDD (const Fqxelem &pol, int n);
template Fqxelem randomPol (const typename Fqxelem::F &field, int degree);
template std::vector< Fqxelem > berlekamp_simple (const Fqxelem &pol);
#ifndef __FACTORIZATION_FQ
#define __FACTORIZATION_FQ

#include<vector>

template<typename Fxelem>
std::vector< Fxelem > berlekamp_simple (const Fxelem &pol);

/*
//Part I
template<typename Fxelem>
std::vector< Fxelem > squareFreeFactorization (const Fxelem &pol); 
 */

//Part II
template<typename Fxelem>
std::vector< std::pair< Fxelem, unsigned int> > partialFactorDD (Fxelem &pol);

//Part III
template<typename Fxelem>
std::vector< Fxelem > splitFactorsDD (const Fxelem &pol, int n);

#endif // __FACTORIZATION_FQ
#include "fp.hpp"
// types.hpp included in fp.hpp
#include "fpelem.hpp"
#include "exceptions.hpp"
#include "generalPurpose.hpp" // Miller Rabin

#include <vector>
#include <string>

Fp::Fp(big_int p): _p(p){
    // TODO create a look-up table for p < 2^16
    if(p<=0 || !millerRabin(p))
        throw EpNotPrime("Could not create F" + std::to_string(p) + ". " + std::to_string(p) + " is not prime.");
}

Fpelem Fp::get(big_int n)const{
    return Fpelem(n, std::unique_ptr<Fp>(new Fp(*this)));
}

big_int Fp::getSize()const{return _p;}

bool Fp::operator==(const Fp &rhs)const{return _p == rhs._p;}
bool Fp::operator!=(const Fp &rhs)const{return _p != rhs._p;}

std::vector<Fpelem> Fp::getElems()const{
    std::vector<Fpelem> ret;
    for(big_int i=0;i<_p;++i)
        ret.push_back(this->get(i));
    return ret;
}
#include "fpelem.hpp"
// types.hpp defined in fpelem.hpp
#include "fp.hpp"
#include "generalPurpose.hpp" // ExtendedEuclideanAlgorithm (eea)
#include "exceptions.hpp"

#include <iosfwd>            // ostream
#include <string>            // to_string
#include <memory>           // unique_ptr

Fpelem::Fpelem ( const Fpelem & other){
    _num = other._num;
    _f = std::unique_ptr<Fp>(new Fp(*other._f));
}

Fpelem & Fpelem::operator=(const Fpelem &rhs){
    if(&rhs != this){
        if(*_f != *rhs._f)
            throw ENotCompatible("Fpelem assignation failed. The elements " + to_string(*this) + " and " + to_string(rhs) + " are in the fields F" + std::to_string(this->getSize()) + " and F" + std::to_string(rhs.getSize()) + " respectively.");
        _num = rhs._num;
    }
    return *this;
}

Fpelem & Fpelem::operator=(big_int rhs){
    *this = _f->get(rhs);
    return *this;
}

bool Fpelem::operator==(const Fpelem &rhs)const{
    return (_num == rhs._num && *_f == *(rhs._f));
}

bool Fpelem::operator!=(const Fpelem &rhs)const{
    return !(*this == rhs);
}

Fpelem & Fpelem::operator+=(const Fpelem &rhs){
    checkInSameField(rhs);
    _num = (big_int) ((ull)_num + (ull)rhs._num)%getSize();
    return *this;
}

const Fpelem Fpelem::operator+(const Fpelem &rhs) const{
    // We do not check if they are in the same field since
    // that will be done in the += operator
    return Fpelem(*this) += rhs;
}

const Fpelem Fpelem::operator-() const{
    return _f->get(-_num);
}

Fpelem & Fpelem::operator-=(const Fpelem &rhs){
    // We do not check if they are in the same field since
    // that will be done in the += operator
    return (*this +=(-rhs));
}

const Fpelem Fpelem::operator-(const Fpelem &rhs) const{
    return Fpelem(*this) -= rhs;
}

/** Russian peasant multiplication
 *   Overview
 *    It multiplies two positive integers of 63 bits and reduces them
 *     modulo p, using integers not bigger than 64 bits.
 *    It circumvents the problem of not having integers greater
 *     than 64 bits in C++.
 *    It does this by computing the multiplication adding 2^i*b(mod p)
 *     to the result if the i-th bit of a is one.
 */
Fpelem & Fpelem::operator*=(const Fpelem &rhs){
    checkInSameField(rhs);

    ull a = _num, b = rhs._num;
    ull res = 0;
    while (a != 0) {
        if (a & 1) res = (res + b) % getSize();
        a >>= 1;
        b = (b << 1) % getSize();
    }
    _num = (ll)res;
    return *this;
}

const Fpelem Fpelem::operator*(const Fpelem &rhs) const{
    // We do not check if they are in the same field since
    // that will be done in the *= operator
    return Fpelem(*this) *= rhs;
}

/** Multiplicative inverse */
const Fpelem Fpelem::inv() const{
    if(_num == 0)
        throw EOperationUnsupported("Error. Zero has no inverse.");
    big_int res, aux;
    eea(_num, getSize(), res, aux);
    return _f->get(res);
}

Fpelem & Fpelem::operator/=(const Fpelem &rhs){
    // We do not check if they are in the same field since
    // that will be done in the *= operator

    return *this *= rhs.inv();
}

const Fpelem Fpelem::operator/(const Fpelem &rhs) const{
    // We do not check if they are in the same field since
    // that will be done in the /= operator
    return Fpelem(*this) /= rhs;
}

big_int Fpelem::getSize()const{return _f->getSize();}

const Fp Fpelem::getField()const{return *_f;}

std::string to_string(const Fpelem &e){return std::to_string(e._num);}
const Fpelem getZero(const Fpelem &e){return e.getField().get(0);}
const Fpelem getOne(const Fpelem &e){return e.getField().get(1);}

bool compatible(const Fpelem &lhs, const Fpelem &rhs){
    return lhs.getField()==rhs.getField();
}

Fpelem::Fpelem(big_int num, std::unique_ptr<Fp> f): _num(num){
    _f = std::move(f);
    big_int p = _f->getSize();
    _num %= p;
    if(_num < 0)
        _num += p;
}

void Fpelem::checkInSameField(const Fpelem &rhs) const{
    if(this->getField() != rhs.getField())
        throw EOperationUnsupported(
            "Error. Is not possible to add the number " + std::to_string(_num) +
            " in F" + std::to_string(getSize()) +
            " with the number " + std::to_string(rhs._num) +
            " in F" + std::to_string(rhs.getSize()));
}

Fpelem & operator+=(Fpelem &lhs, big_int rhs){
    lhs+=lhs.getField().get(rhs);
    return lhs;
}

const Fpelem operator+(const Fpelem &lhs, big_int rhs){
    return lhs + lhs.getField().get(rhs);
}

const Fpelem operator+(big_int lhs, const Fpelem & rhs){
    return rhs.getField().get(lhs) + rhs;
}

Fpelem & operator-=(Fpelem &lhs, big_int rhs){
    lhs-=lhs.getField().get(rhs);
    return lhs;
}

const Fpelem operator-(const Fpelem &lhs, big_int rhs){
    return lhs - lhs.getField().get(rhs);
}

const Fpelem operator-(big_int lhs, const Fpelem & rhs){
    return rhs.getField().get(lhs) - rhs;
}

bool operator==(const Fpelem & lhs, big_int rhs){
    return lhs == lhs.getField().get(rhs);
}

bool operator==(big_int lhs, const Fpelem &rhs){
    return rhs == lhs;
}

bool operator!=(const Fpelem & lhs, big_int rhs){
    return !(lhs == rhs);
}

bool operator!=(big_int lhs, const Fpelem &rhs){
    return !(lhs == rhs);
}

std::ostream& operator<<(std::ostream& os, const Fpelem &e){
    os << to_string(e);
    return os;
}
#ifndef __FPELEM_HPP
#define __FPELEM_HPP

#include "fp.hpp"
#include "types.hpp"

#include <iosfwd>           // ostream
#include <memory>           // unique_ptr

class Fp;

class Fpelem{
    public:
        // Base field
        using F = Fp;

        Fpelem ( const Fpelem & );
        Fpelem & operator=(const Fpelem &rhs);

        Fpelem & operator=(big_int rhs);

        bool operator==(const Fpelem &rhs)const;

        bool operator!=(const Fpelem &rhs)const;

        Fpelem & operator+=(const Fpelem &rhs);

        const Fpelem operator+(const Fpelem &rhs) const;

        const Fpelem operator-() const;

        Fpelem & operator-=(const Fpelem &rhs);

        const Fpelem operator-(const Fpelem &rhs) const;

        Fpelem & operator*=(const Fpelem &rhs);

        const Fpelem operator*(const Fpelem &rhs) const;

        /** Multiplicative inverse */
        const Fpelem inv() const;

        Fpelem & operator/=(const Fpelem &rhs);

        const Fpelem operator/(const Fpelem &rhs) const;

        friend int deg(const Fpelem &e);

        const Fpelem operator%(const Fpelem &rhs) const;

        big_int getSize()const;

        const F getField()const;

        friend std::ostream& operator<<(std::ostream& os, const Fpelem &e);
        friend std::string to_string(const Fpelem &e);

    private:
        friend class Fp;

        Fpelem(big_int num, std::unique_ptr<F> f);
        void checkInSameField(const Fpelem &rhs) const;

        big_int _num;
        std::unique_ptr<F> _f;
};

bool operator==(big_int lhs, const Fpelem &rhs);
bool operator==(const Fpelem &lhs, big_int rhs);
bool operator!=(big_int lhs, const Fpelem &rhs);
bool operator!=(const Fpelem &lhs, big_int rhs);
Fpelem & operator+=(Fpelem &lhs, big_int rhs);
const Fpelem operator+(const Fpelem &lhs, big_int rhs);
const Fpelem operator+(big_int lhs, const Fpelem & rhs);
Fpelem & operator-=(Fpelem &lhs, big_int rhs);
const Fpelem operator-(const Fpelem &lhs, big_int rhs);
const Fpelem operator-(big_int lhs, const Fpelem & rhs);

bool compatible(const Fpelem &lhs, const Fpelem &rhs);
const Fpelem getZero(const Fpelem &e);
const Fpelem getOne(const Fpelem &e);
std::string to_string(const Fpelem &e);

#endif // __FPELEM_HPP
#ifndef __FIELDP_HPP
#define __FIELDP_HPP

#include "types.hpp"

#include <vector>

class Fpelem;

class Fp{
    public:
        Fp(big_int p);

        Fpelem get(big_int n)const;

        big_int getSize()const;

        std::vector<Fpelem> getElems()const;

        bool operator==(const Fp &rhs)const;
        bool operator!=(const Fp &rhs)const;


    private:
        big_int _p;
};

#endif // __FP_HPP
#include "fpxelem.hpp"
#include "generalPurpose.hpp" // fastPowMod

#include <vector>
// Fpelem included in fpxelem.hpp

Fpxelem::Fpxelem(const Fpelem & e) : PolynomialRing<Fpxelem, Fpelem>(e){}
Fpxelem::Fpxelem(const std::vector<Fpelem> & v) : PolynomialRing<Fpxelem, Fpelem>(v){}

const Fpxelem::F Fpxelem::getField()const{
    return this->lc().getField();
}

big_int Fpxelem::getSize()const{
    return this->getField().getSize();
}

bool Fpxelem::irreducible()const{
    Fpxelem x({this->getField().get(0), this->getField().get(1)});
    Fpxelem xpk = x; // x^(p^k)

    for(int i=0;i<this->deg()/2;++i){
        xpk = fastPowMod<Fpxelem>(xpk, this->getSize(), *this);
        if(gcd(*this, xpk-x).deg()!=0)
            return false;
    }
    return true;
}

Fpxelem getZero(const Fpxelem &e){return Fpxelem(e.getField().get(0));}
Fpxelem getOne(const Fpxelem &e){return Fpxelem(e.getField().get(1));}

const Fpelem unit(const Fpxelem &e){ return e.lc(); }

bool compatible(const Fpxelem &lhs, const Fpxelem &rhs){
    return lhs.getField()==rhs.getField();
}

bool operator==(const Fpxelem &lhs, big_int rhs){
    return lhs.deg()==0 && lhs.lc()==lhs.getField().get(rhs);
}

bool operator==(big_int lhs, const Fpxelem &rhs){
    return rhs == lhs;
}

bool operator!=(const Fpxelem &lhs, big_int rhs){
    return !(lhs == rhs);
}

bool operator!=(big_int lhs, const Fpxelem &rhs ){
    return !(rhs == lhs);
}

// Implementation of a GF(p) field
#ifndef __FPXELEM2_HPP
#define __FPXELEM2_HPP

#include "fp.hpp"
#include "fpelem.hpp"
#include "polRing.hpp"


class Fpxelem : public PolynomialRing<Fpxelem, Fpelem>{
    public:
        // Base field
        using F = Fp;
        using Felem = Fpelem;

        Fpxelem(const Fpelem & e);
        Fpxelem(const std::vector<Fpelem> & v);

        bool irreducible()const;
        const F getField()const;
        big_int getSize()const;
};

Fpxelem getZero(const Fpxelem &e);
Fpxelem getOne(const Fpxelem &e);
const Fpelem unit(const Fpxelem &e);
bool compatible(const Fpxelem &lhs, const Fpxelem &rhs);
bool operator==(const Fpxelem &lhs, big_int rhs);
bool operator==(big_int lhs, const Fpxelem &rhs);
bool operator!=(const Fpxelem &lhs, big_int rhs);
bool operator!=(big_int lhs, const Fpxelem &rhs );

#endif
#include "fq.hpp"
#include "fqelem.hpp"
// Included in header "fpxelem.hpp"
#include "exceptions.hpp"
#include "generalPurpose.hpp" // Miller Rabin

#include <vector>
#include <string>

// Auxiliary function
bool increment(std::vector<Fpelem>& act) {
    for(auto e = act.begin(); e != act.end(); ++e){
        *e += 1;
        if (*e != 0)
            return true;
    }
    return false; // We are done
}

Fq::Fq(ll p, int n): _p(p), _n(n), _base(p), _mod(_base.get(0)){ // _mod must be explicitly initialized
    std::vector<Fpelem> v (_n+1, _base.get(0));

    v.back() = _base.get(1);
    v[0] = _base.get(1);
    // Hopefully this ends in a reasonable amount of time
    //  Maybe set a timer?
    //  The probability of getting an irreducible polynomial
    //   in each iteration is 1/n
    while(!Fpxelem(v).irreducible()){
        increment(v);
        if(v[0] == 0) // It's divisible by the polynomial p(x) = x
            increment(v);
    }
    _mod = Fpxelem(v);
}

Fqelem Fq::get(ll n)const{
    return Fqelem(Fpxelem(_base.get(n)), _mod, std::unique_ptr<Fq>(new Fq(*this)));
}

Fqelem Fq::get(Fpxelem f)const{
    return Fqelem(f, _mod, std::unique_ptr<Fq>(new Fq(*this)));
}

ll Fq::getSize()const{return (ll) std::pow((double)_p,(double)_n);}

bool Fq::operator==(const Fq &rhs)const{return _p == rhs._p && _n == rhs._n;}
bool Fq::operator!=(const Fq &rhs)const{return _p != rhs._p && _n != rhs._n;}

std::vector<Fqelem> Fq::getElems()const{
    std::vector<Fqelem> ret;
    std::vector<Fpelem> act(_n, _base.get(0));

    do {
        ret.push_back(this->get(Fpxelem(act)));
    } while (increment(act));
    return ret;
}

std::string to_string(const Fq &e){
    return "GF(" + std::to_string(e._p) + "^" + std::to_string(e._n) + ")";
}

#include "exceptions.hpp"
#include "fqelem.hpp"
// types.hpp defined in fpelem.hpp
#include "fpelem.hpp"
#include "fpxelem.hpp"
#include "fq.hpp"
#include "generalPurpose.hpp" // ExtendedEuclideanAlgorithm (eea)

#include <iosfwd>            // ostream
#include <memory>           // unique_ptr

Fqelem::Fqelem ( const Fqelem & other) : _num(other._num), _mod(other._mod){
    _f = std::unique_ptr<Fqelem::F>(new Fqelem::F(*other._f));
}

Fqelem & Fqelem::operator=(const Fqelem &rhs){
    if(&rhs != this){
        checkInSameField(rhs);
        _num = rhs._num;
    }
    return *this;
}

Fqelem & Fqelem::operator=(ll rhs){
    *this = _f->get(rhs);
    return *this;
}

bool Fqelem::operator==(const Fqelem &rhs)const{
    return (_num == rhs._num && *_f == *(rhs._f));
}

bool Fqelem::operator!=(const Fqelem &rhs)const{
    return !(*this == rhs);
}

Fqelem & Fqelem::operator+=(const Fqelem &rhs){
    checkInSameField(rhs);
    _num = (_num + rhs._num) % _mod;
    return *this;
}

const Fqelem Fqelem::operator+(const Fqelem &rhs) const{
    // We do not check if they are in the same field since
    // that will be done in the += operator
    return Fqelem(*this) += rhs;
}

const Fqelem Fqelem::operator-() const{
    return _f->get(-_num);
}

Fqelem & Fqelem::operator-=(const Fqelem &rhs){
    // We do not check if they are in the same field since
    // that will be done in the += operator
    return (*this +=(-rhs));
}

const Fqelem Fqelem::operator-(const Fqelem &rhs) const{
    return Fqelem(*this) -= rhs;
}

Fqelem & Fqelem::operator*=(const Fqelem &rhs){
    checkInSameField(rhs);
    _num = (_num * rhs._num) % _mod;
    return *this;
}

const Fqelem Fqelem::operator*(const Fqelem &rhs) const{
    // We do not check if they are in the same field since
    // that will be done in the *= operator
    return Fqelem(*this) *= rhs;
}

/** Multiplicative inverse */
const Fqelem Fqelem::inv() const{
    if(_num == 0)
        throw EOperationUnsupported("Error. Zero has no inverse.");
    Fpxelem res = _f->get(0)._num, aux = _f->get(0)._num;
    eea(_num, _mod, res, aux);
    return _f->get(res);
}

Fqelem & Fqelem::operator/=(const Fqelem &rhs){
    // We do not check if they are in the same field since
    // that will be done in the *= operator

    return *this *= rhs.inv();
}

const Fqelem Fqelem::operator/(const Fqelem &rhs) const{
    // We do not check if they are in the same field since
    // that will be done in the /= operator
    return Fqelem(*this) /= rhs;
}

int deg(const Fqelem &e){return e._num.deg();}

// In a field the division has reminder zero
const Fqelem Fqelem::operator%(const Fqelem &rhs) const{return _f->get(0);}

ll Fqelem::getSize()const{return _f->getSize();}

const Fqelem::F Fqelem::getField()const{return *_f;}

std::string to_string(const Fqelem &e){return to_string(e._num);}
const Fqelem getZero(const Fqelem &e){return e.getField().get(0);}
const Fqelem getOne(const Fqelem &e){return e.getField().get(1);}

bool compatible(const Fqelem &lhs, const Fqelem &rhs){
    return lhs.getField()==rhs.getField();
}

Fqelem::Fqelem(Fpxelem num, Fpxelem mod,  std::unique_ptr<Fqelem::F> f): _num(num), _mod(mod){
    _f = std::move(f);
}

void Fqelem::checkInSameField(const Fqelem &rhs) const{
    if(this->getField() != rhs.getField())
        throw EOperationUnsupported(
            "Error. Is not possible to add the number " + to_string(_num) +
            " in " + to_string(this->getField()) +
            " with the number " + to_string(rhs._num) +
            " in F" + to_string(rhs.getField()));
}

Fqelem & operator+=(Fqelem &lhs, ll rhs){
    lhs+=lhs.getField().get(rhs);
    return lhs;
}

const Fqelem operator+(const Fqelem &lhs, ll rhs){
    return lhs + lhs.getField().get(rhs);
}

const Fqelem operator+(ll lhs, const Fqelem & rhs){
    return rhs.getField().get(lhs) + rhs;
}

Fqelem & operator-=(Fqelem &lhs, ll rhs){
    lhs-=lhs.getField().get(rhs);
    return lhs;
}

const Fqelem operator-(const Fqelem &lhs, ll rhs){
    return lhs - lhs.getField().get(rhs);
}

const Fqelem operator-(ll lhs, const Fqelem & rhs){
    return rhs.getField().get(lhs) - rhs;
}

bool operator==(const Fqelem & lhs, ll rhs){
    return lhs == lhs.getField().get(rhs);
}

bool operator==(ll lhs, const Fqelem &rhs){
    return rhs == lhs;
}

bool operator!=(const Fqelem & lhs, ll rhs){
    return !(lhs == rhs);
}

bool operator!=(ll lhs, const Fqelem &rhs){
    return !(lhs == rhs);
}

std::ostream& operator<<(std::ostream& os, const Fqelem &e){
    os << to_string(e);
    return os;
}
#ifndef __FQELEM_HPP
#define __FQELEM_HPP

#include "types.hpp"
// I don't think this is necessary
#include "fq.hpp"
#include <iosfwd>           // ostream
#include <memory>           // unique_ptr

class Fq;

class Fqelem{
    public:
        // Base field
        using F = Fq;

        Fqelem ( const Fqelem & );
        Fqelem & operator=(const Fqelem &rhs);

        Fqelem & operator=(ll rhs);

        bool operator==(const Fqelem &rhs)const;

        bool operator!=(const Fqelem &rhs)const;

        Fqelem & operator+=(const Fqelem &rhs);

        const Fqelem operator+(const Fqelem &rhs) const;

        const Fqelem operator-() const;

        Fqelem & operator-=(const Fqelem &rhs);

        const Fqelem operator-(const Fqelem &rhs) const;

        Fqelem & operator*=(const Fqelem &rhs);

        const Fqelem operator*(const Fqelem &rhs) const;

        /** Multiplicative inverse */
        const Fqelem inv() const;

        Fqelem & operator/=(const Fqelem &rhs);

        const Fqelem operator/(const Fqelem &rhs) const;

        friend int deg(const Fqelem &e);

        const Fqelem operator%(const Fqelem &rhs) const;

        ll getSize()const;

        const F getField()const;

        friend std::ostream& operator<<(std::ostream& os, const Fqelem &e);
        friend std::string to_string(const Fqelem &e);

    private:
        friend class Fq;

        Fqelem(Fpxelem n, Fpxelem mod, std::unique_ptr<F> f);
        void checkInSameField(const Fqelem &rhs) const;

        Fpxelem _num;
        std::unique_ptr<F> _f;
        Fpxelem _mod;
};

bool operator==(ll lhs, const Fqelem &rhs);
bool operator==(const Fqelem &lhs, ll rhs);
bool operator!=(ll lhs, const Fqelem &rhs);
bool operator!=(const Fqelem &lhs, ll rhs);
Fqelem & operator+=(Fqelem &lhs, ll rhs);
const Fqelem operator+(const Fqelem &lhs, ll rhs);
const Fqelem operator+(ll lhs, const Fqelem & rhs);
Fqelem & operator-=(Fqelem &lhs, ll rhs);
const Fqelem operator-(const Fqelem &lhs, ll rhs);
const Fqelem operator-(ll lhs, const Fqelem & rhs);

bool compatible(const Fqelem &lhs, const Fqelem &rhs);
const Fqelem getZero(const Fqelem &e);
const Fqelem getOne(const Fqelem &e);
std::string to_string(const Fqelem &e);

#endif // __FQELEM_HPP
#ifndef __FIELDQ_HPP
#define __FIELDQ_HPP

#include "types.hpp"
#include "fp.hpp"
#include "fpxelem.hpp"

#include <vector>

class Fqelem;

class Fq{
    public:
        Fq(ll p, int n);

        Fqelem get(ll n)const;

        Fqelem get(Fpxelem f)const;

        ll getSize()const;

        std::vector<Fqelem> getElems()const;

        bool operator==(const Fq &rhs)const;
        bool operator!=(const Fq &rhs)const;

        friend std::string to_string(const Fq &e);
    private:

        ll _p;
        int _n;
        Fp _base;
        Fpxelem _mod;
};

#endif // __FIELDQ_HPP
#include "fqxelem.hpp"
#include "generalPurpose.hpp" // fastPowMod

#include <vector>
// Fqelem included in fpxelem.hpp

Fqxelem::Fqxelem(const Fqelem & e) : PolynomialRing<Fqxelem, Fqelem>(e){}
Fqxelem::Fqxelem(const std::vector<Fqelem> & v) : PolynomialRing<Fqxelem, Fqelem>(v){}

const Fqxelem::F Fqxelem::getField()const{
    return this->lc().getField();
}

ll Fqxelem::getSize()const{
    return this->getField().getSize();
}

Fqxelem getZero(const Fqxelem &e){return Fqxelem(e.getField().get(0));}
Fqxelem getOne(const Fqxelem &e){return Fqxelem(e.getField().get(1));}


const Fqelem unit(const Fqxelem &e){ return e.lc(); }

bool compatible(const Fqxelem &lhs, const Fqxelem &rhs){
    return lhs.getField()==rhs.getField();
}

bool operator==(const Fqxelem &lhs, ll rhs){
    return lhs.deg()==0 && lhs.lc()==lhs.getField().get(rhs);
}

bool operator==(ll lhs, const Fqxelem &rhs){
    return rhs == lhs;
}

bool operator!=(const Fqxelem &lhs, ll rhs){
    return !(lhs == rhs);
}

bool operator!=(ll lhs, const Fqxelem &rhs ){
    return !(rhs == lhs);
}

// Implementation of a GF(p) field
#ifndef __FQXELEM_HPP
#define __FQXELEM_HPP

#include "fq.hpp"
#include "fqelem.hpp"
#include "polRing.hpp"


class Fqxelem : public PolynomialRing<Fqxelem, Fqelem>{
    public:
        // Base field
        using F = Fq;
        using Felem = Fqelem;

        Fqxelem(const Fqelem & e);
        Fqxelem(const std::vector<Fqelem> & v);

        const F getField()const;
        ll getSize()const;
};

Fqxelem getZero(const Fqxelem &e);
Fqxelem getOne(const Fqxelem &e);
const Fqelem unit(const Fqxelem &e);
bool compatible(const Fqxelem &lhs, const Fqxelem &rhs);
bool operator==(const Fqxelem &lhs, ll rhs);
bool operator==(ll lhs, const Fqxelem &rhs);
bool operator!=(const Fqxelem &lhs, ll rhs);
bool operator!=(ll lhs, const Fqxelem &rhs );

#endif
#include <cstdlib> // abs function for long long ints
#include "exceptions.hpp"
#include "types.hpp"
#include "zelem.hpp" // getZero y tal
#include "fpxelem.hpp"

/**
 * Exponentiation by Squaring
 *
 * Explanation:
 *  Computes a^b (mod m)
 * Theoretical background:
 *  The algorithm is based on the fact that:
 *  a^0 = 1
 *  a^{2k} (mod m) = (a^k (mod m) * a^k (mod m)) (mod m)
 *  a^{2k+1} (mod m) = (a*(a^{2k} (mod m)) (mod m)
 *
 * Complexity:
 *  O((b*log(a))) supposing multiplication in O(1)
 */
template<typename T, typename U>
T fastPowMod(T a, U b, T p){
    if(b==0)return getOne(a);
    if(b%2 != 0){
    	return (a*fastPowMod(a,b-1,p))%p;
    }
    else{
    	T aux = fastPowMod(a,b/2,p);
    	return (aux*aux)%p;
    }
}
//template ll fastPowMod(ll a, ll b, ll p);
template big_int fastPowMod(big_int a, ll b, big_int p);
template Fpxelem fastPowMod(Fpxelem a, ll b, Fpxelem p);

/**
 * Miller Rabin: Primality Test
 *
 * Description:
 *  Montecarlo primality test for positive integers
 *
 * Theoretical background:
 *  A prime number is odd
 *  Z_p is a field iff p is prime
 *  A field does not contain any non-trivial root of the unity
 *  By Fermat's little theorem if p is prime, a^{p-1} = 1 (mod p)
 *  - Decompose n-1 = s*2^r
 *  - For some random a<-{2,..,n-2}
 *  - Check that (a^s)^2^i is not a trivial root of the unity of i=1..r-1 in Z_n
 *      This tranlsates into the test (a^s)^2^i = 1 (mod n)
 *  - Check that (a^s)^2^r = a^{n-1} = 1 in Z_n
 *
 * Complexity:
 *  O(k*log^3(n))
 *  Probability of false posiive: 4^{-k}
 *
 * Remarks:
 *  Even though here we implement the classical version of the algorithm, if we
 *   restrict ourselves to long long integers, it is enough to check with:
 *  a = 2,3,4,5,11,13,17,19,23,29,31 and 37
 */
bool millerRabin(big_int n, int k /*= 35*/){
    big_int s=n-1, a;
    ll r=0;

    // Discards edge cases for the random generation process
    if(n==2 || n==3) return true;
    // Check that n is odd and greater than 1
    if(n%2==0 || n==1) return false;

    // Decompose n-1 as n-1=s*2^r
    while(s%2==0){
        s/=2;
        r++;
    }
    while(k--) {
        // Generate a random number a<-{2..n-2}
        a=(rand()%(n-3))+2;
        a=fastPowMod(a, s, n);

        // if a=1,n-1, we are not going to find any non trivial root
        // since a^2 (mod n) = 1
        if(a==1 || a == n-1) continue;

        for(int i=0; i<r; i++){
            a=(a*a)%n;

            // If we find a non trivial root of the unity
            if(a==1) return false;

            // By fermat's little theorem a^{n-1}=1 (mod n) if n prime
            if(i==r-1 && a!=1) return false;

            // We are not going to find any nontrivial root of unity
            if(a==n-1) break;
        }
    }
    return true;
}

/**
 * Extended Euclidean Algorithm
 *
 * Description:
 *  Given two integers a, b it computes:
 *   ax+by=d=gcd(a,b)
 *   It returns d with  d > 0, i.e. in its normal form.
 *
 * Theoretical background:
 *  The algorithm is based in the equality mcd(a,b)=mcd(b%a,a)
 *  The details of the invariants are commented in the code
 *  This algorithm works with a few tweaks for an arbitrary Euclidean Domain
 *
 * Complexity:
 *  O(log(min(a,b)))
 *
 */
ll eea(ll a, ll b, ll& x, ll& y){
    // We set a = |a| and b = |b| and set a flag if the sign was changed
    bool ca = false, cb = false;
    if(a < 0)a = -a, ca = true;
    if(b < 0)b = -b, cb = true;

    x = 1; y = 0;
    ll xx = 0, yy = 1;
    ll q, r, r1, r2;
    while(b){
        // The following invariant holds:
        //  a = x*|a|+y*|b|
        //  b = xx*|a|+yy*|b|

        // Compute quotient and reminder
        q = a/b; r = a-q*b;

        // After this r = r1*|a|+r2*|b| holds
        r1 = x-q*xx; r2 = y-q*yy;

        // Iterate
        a = b; x = xx; y = yy;
        b = r; xx = r1; yy = r2;
    }
    if(ca) x = -x;
    if(cb) y = -y;

    return std::abs(a);
}

ll gcd(ll a, ll b){
    ll x,y;
    return eea(a,b,x,y);
}

/**
 * Extended Euclidean Algorithm for an arbitrary DFU
 */
template<typename T>
T eea (T a, T b, T &x, T &y){
    if(a == 0){
        if(b == 0)
            throw EOperationUnsupported("Cannot compute the greatest common divisor of two zero elements.");
        x = getZero(a);
        y = unit(b);
        return normalForm(b);
    }
    if(b == 0){
        x = unit(a);
        y = getZero(b);
        return normalForm(a);
    }
    a = normalForm(a);
    b = normalForm(b);

    T ua = unit(a), ub = unit(b);

      x = getOne(a); y = getZero(b);
    T xx = getZero(a), yy = getOne(b);
    while(b!=0){
        // The following invariant holds:
        //  a = x*|a|+y*|b|
        //  b = xx*|a|+yy*|b|

        // Compute quotient and reminder
        T q = a/b, r = a-q*b;

        // After this r = r1*|a|+r2*|b| holds
        T r1 = x-q*xx, r2 = y-q*yy;

        // Iterate
        a = b; x = xx; y = yy;
        b = r; xx = r1; yy = r2;
    }
    x /= unit(ua*unit(a));
    y /= unit(ub*unit(a));
    return normalForm(a);
}

template Fpxelem eea (Fpxelem a, Fpxelem b, Fpxelem &x, Fpxelem &y);
//template ll eea (ll a, ll b, ll &x, ll &y);

template<typename T>
T gcd(T a, T b){
    T x = getZero(a), y = getZero(b);
    return eea(a,b,x,y);
}
template big_int gcd(big_int a, big_int b);
template Fpxelem gcd(Fpxelem a, Fpxelem b);



template<typename T>
T fastPow (T a, ll b){
	if (b == 0)
		return 1;
	else{
		T aux = a; 
		T result = 1;
		while (b != 0){
			if (b % 2 == 0){
				aux*=aux;
				b /= 2;
			}	
			else{
				result *= aux;
				aux *= aux;
				b -= 1;
			}
		}
		return result;
	}
	
}
template big_int fastPow (big_int a, ll b);
#ifndef __GENERAL_PURPOSE_H
#define __GENERAL_PURPOSE_H

#include "types.hpp"

template<typename T> T fastPowMod(T a, ll b, T p);
bool millerRabin(ll n, int k = 35);
template<typename T> T eea (T a, T b, T &x, T &y);
template<typename T> T gcd(T a, T b);
template<typename T> T fastPow (T a, ll b);
#endif // __GENERAL_PURPOSE_H
#include "fp.hpp"
#include "fpelem.hpp"
#include "fpxelem.hpp"
#include "zelem.hpp"
#include "zxelem.hpp"
#include "types.hpp"


/**
 * Input:
 *		1) A primitive polynomial pol
 *		2) A prime integer p which does not divide pol[pol.degree]
 *		3) Two relatively primes polynomials u1, w1 \in Z_p[X] such that
 *			pol = u1*w1 (mod p)
 *		4) A bound B of all integer coefficients of pol and all coefficients
 *			of u, v
 *
 * Output: Two polynomials u, w (if there are such polynomials) such that
 * 			pol = u*w and such that u' = u1' (mod p) and w' = w1' (mod p)
 * 			where v' stands for the monic normalization of v (mod p)
 * 			If there are not such polynomials ...
 */

/* Cosas que necesito
 * 		Polinomios en Z, es decir Z[x]
 *		Multiplicar un big_int por un Zx
 *		Comparación del un polinomio en Zx con el número 0
 *		Dividir un polinomio en Zx por un entero
 *		Sumar polinomios en Z_p[x] con polinomios en Z[x]
 *
 * */
bool HenselLifting (const Zx &polynomial, int p, const Fpxelem &u1, const Fpxelem &w1, big_int bound, Zx & u, Zx & w){
	big_int leadCoef = polynomial.lc();
	Zx pol = polynomial * leadCoef;
	Fpxelem::Felem lc(leadCoef);
	u1 *=  (lc * u1.lc().inv()); //This is more efficient than normalize and then multiply by lc
	w1 *=  (lc * w1.lc().inv());

	Fpxelem s, t;
	eea (u1, w1, &s, &t);//This must always be 1. Test it!!

	u = Zx(u1); u[u.getSize()] = leadCoef;
	w = Zx(w1); w[w.getSize()] = leadCoef;
	Zx err = pol - u*w;
	big_int modulus = p;
	bound = 2*bound*leadCoef;

	while (err != 0 && modulus < bound ){
		Fpxelem c(err/modulus);
		pair< Fpxelem, Fpxelem > qr = div2 (s*c, w1);
 		u += Zx(t*c + qr.first * u1) * modulus;
		w += Zx(qr.second) * modulus; 
		err = pol - u*w;
		modulus *= p;
	}

	if (err == 0){
		big_int delta = cont(u);
		u /= delta;
		w /= (leadCoef / delta); //delta must be a divisor of leadCoef (Test it!!)
		return true;
	}
	return false;
}
#include <vector>
#include "types.hpp"
#include "generalPurpose.hpp"

/* Auxiliary function. Finds x such that
 * ax = 1 (mod q)
 * */
big_int reciprocal (big_int a, big_int q){
	big_int x, y;
	eea (a, q, x, y);
	return x;
}

/**
 * Integer Chinese Remainder Algorithm (Garner's Algorithm)
 * Description:
 *  Given positive moduli m_i \in Z (0 \leq i \leq n) which are
 *   relatively prime and given corresponding residues u_i \in Z_{m_i}
 *   compute the unique integer u \in Z_m (where m = \prod m_i) such that
 *   u = u_i (mod m_i) i = 0,...,n
 *
 * Theoretical background:
 *  The algorithm express the solution in the mixed radix representation:
 * 		u = v_0 + v_1 m_0 + ... + v_n (\prod_{i=0}^{n-1} m_i)
 *  where v_k \in Z_{m_k} k = 0..n
 *
 *  Now v_0 = u_0 and for k >= 1 we have (mod m_k):
 * 		u_k = v_0 + ... + v_k (\prod_{i=0}^{k-1})
 * 	and we know everything but v_k so we compute it solving the equation
 * 	(we need to compute the inverse of \prod_{i=0}^{k-1} (mod m_k). We
 * 	precompute all those inverses.
 *
 * Complexity:
 *  O(n^2)
 *
 */
big_int integerCRA (const std::vector<big_int> & m, const std::vector<big_int> & u){
	//TODO: ¿Comprobar que u y m tienen el mismo tamaño?
	int n = m.size()-1;
	big_int prod, aux;
	std::vector<big_int> inv, v;
	for (int k = 1; k <= n; ++k ){
		prod = m[0]%m[k];
		for	(int i = 1 ; i <= k-1; ++i)
			prod = (prod*m[i])%m[k];
		inv.push_back(reciprocal(prod, m[k]));	//inv starts in 0, in the book it starts in 1
	}
	v.push_back(u[0]);
	for (int k = 1; k <= n; ++k){
		aux = v[k-1];
		for (int j = k-2; j >=0; --j)
			aux = (aux*m[j]+v[j])%m[k];
		v.push_back(((u[k]-aux)*inv[k-1])%m[k]);	//it is inv[k-1] because inv starts in 0
	}
	big_int result = v[n];
	for (int k = n-1; k >= 0; --k ){
		result = result*m[k] + v[k];
	}
	return result;
}
#ifndef __integerCRA
#define __integerCRA

#include "types.hpp"
#include <vector>

big_int integerCRA (const std::vector<big_int> & m, const std::vector<big_int> & u);


#endif // __integerCRA
#include <iostream>
#include <vector>
#include <boost/multiprecision/cpp_int.hpp>
//#include"gtest/gtest.h"


#include "types.hpp"
#include "fp.hpp"
#include "fpelem.hpp"
#include "fpxelem.hpp"
#include "fq.hpp"
#include "fqelem.hpp"
#include "zxelem.hpp"
#include "exceptions.hpp"
#include "factorizationFq.hpp"
#include "integerCRA.hpp"
using namespace std;
using namespace boost::multiprecision;

int main (){
    cpp_int fact= (cpp_int(1)<<128)-1;
    cout << fact << endl;
}
	int c[11]= {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
	Fp field(11);
	vector<Fpelem> v;
	for(int i=0;i<=10;++i)
		v.push_back(field.get(c[i]));
	Fpxelem a(v);
	std::vector< Fpxelem > factors = splitFactorsDD (a, 2);
	for (int i =0; i< factors.size(); i++){
			cout << factors[i] << endl;
	}
}


    /*
    vector<Fpelem> v, w;
    Fp field(11);
    try{
		int c[7]= {1, -3, -1, -3, 1, -3, 1};
		v.push_back(field.get(-1));
        for(int i=1;i<=10;++i)
        	v.push_back(field.get(0));
        v.push_back(field.get(1));
		Fpxelem a(v);
		cout << a << endl;
		std::vector< pair < Fpxelem, unsigned int > > qw = partialFactorDD (a);
		cout << qw.size() << endl;
		cout << qw[0].first << " " << qw[0].second << endl;
		cout << qw[1].first << " " << qw[1].second << endl;
		cout << qw[2].first << " " << qw[2].second << endl;
    }catch(ExcepALCP e){
        cout << e << endl;
    }
}
}
    Fp field(5);
    Fpelem f = field.get(3);
    Fpelem g = field.get(4);
    cout << f << endl;
    cout << f+g << endl;
    cout << f + field.get(2) << endl;
    cout << f + 3 << endl;

    Fp field2(17);
    vector<Fpelem> v, w;
    for(int i=0;i<5;++i)
        v.push_back(field2.get(i+2));
    for(int i=0;i<6;++i){
        w.push_back(field2.get(3*i+3));
    }
    Fpxelem a(v), b(w);
    cout << "a\n" << a << endl;
    cout << "b\n" << b << endl;

   try{
        //cout << Fpelem(3,6)<<endl; //Throws except
        cout << std::boolalpha << (Fp(5).get(0) == Fp(5).get(5)) << endl;
        cout << "Suma a+b\n" << a+b << endl;
        cout << "suma b+a\n" << b+a << endl;
        cout << "Resta b-a\n" <<b-a << endl;
        cout << "Resta a-b\n" << a-b << endl;
        cout << "Multip a*b\n" << a*b << endl;
        std::pair<Fpxelem,Fpxelem> div1 = a.div2(b);
        std::cout << "Div & Mod a/b" << std::endl;
        std::cout << div1.second << std::endl;
        std::cout << div1.first << std::endl;

        std::pair<Fpxelem,Fpxelem> div2 = b.div2(a);
        std::cout << "Div & Mod b/a" << std::endl;
        std::cout << div2.first << std::endl << div2.second << std::endl;
        // Until here everything is ok
        */
/*Para berlekamp
    vector<Fpelem> v, w;
    Fp field(11);
    try{
		int c[7]= {1, -3, -1, -3, 1, -3, 1};
        for(int i=0;i<7;++i)
            v.push_back(field.get(c[i]));
		Fpxelem a(v);

		std::vector< Fpxelem > qw = berlekamp_simple (a);
		cout << qw[0] << endl;
		cout << qw[1] << endl;
		cout << qw[2] << endl;
    }catch(ExcepALCP e){
        cout << e << endl;
    }

}*/
/*
        for(int i=0;i<5;++i)
            v.push_back(field.get(7*i));
        for(int i=0;i<6;++i){
            w.push_back(field.get(5*i+2));
        }
        Fpxelem a(v), b(w);
        cout << a.deg() << endl;
        cout << b.deg() << endl;
        cout << "a: " << a << endl;
        cout << "b: " << b << endl;

        cout << "Suma a+b\n" << a+b << endl;
        cout << "suma b+a\n" << b+a << endl;
        cout << "Resta b-a\n" <<b-a << endl;
        cout << "Resta a-b\n" << a-b << endl;
        cout << "Multip a*b\n" << a*b << endl;
        std::pair<Fpxelem,Fpxelem> div1 = a.div2(b);
        std::cout << "Div & Mod a/b" << std::endl;
        std::cout << div1.second << std::endl;
        std::cout << div1.first << std::endl;

        std::pair<Fpxelem,Fpxelem> div2 = b.div2(a);
        std::cout << "Div & Mod b/a" << std::endl;
        std::cout << div2.first << std::endl << div2.second << std::endl;
*/

 /*   try{
        Fp f (17);
        vector<Fpelem> w;
        for(int i=0;i<6;++i){
            w.push_back(f.get(5*i+2));
        }
        cout << "ok2" << endl;
        Fpxelem b(w);
        cout << b / Fpxelem(f.get(3)) << endl;

    }catch(ExcepALCP e){
        cout << e << endl;
    }

}
*/
/*
TEST(AddPolTest, Some){
    vector<Fpelem> v, w;
    Fp f(17);
    for(int i=0;i<5;++i)
        v.push_back(f.get(7*i));
    for(int i=0;i<6;++i){
        w.push_back(f.get(5*i+2));
    }
    Fpxelem a(v), b(w);
    EXPECT_EQ(Fpxelem({f.get(2),f.get(14),f.get(9),f.get(4),f.get(16),f.get(10)}), a+b);
}*/
//EN PROCESO... NO LO LEAS XD

big_int intContent (const FX & a){
	//Calcula el gcd de los coeficientes con el signo del coeficiente director
}


/* Modular GCD 
 *  Given A, B \in Z[x_1..x_k] nonzero, it obtains gcd (A, B) via modular
 *  reduction.
 * */
//TODO: ¿Como representamos los polynomios en varias variables?
const modularGCD FX & (const FX & a, const FX & b){
	big_int ia = intContent(a); a /= ia;
	big_int ib = intContent(b); b /= ib;
	//Compute coefficient bound of gcd(a, b)
	big_int c = gcd (ia, ib);
	big_int g = gcd (a.leadingCoef, b.leadingCoef); //TODO
	if (g < 0) g = -g;
	big_int q = 0, h = 0, p;
	int n = min (a.degree(), b.degree());
	big_int limit = (1<<n)*g*min(normInf(a), normInf(b));
	
	while (true){
		p = generateNewLargePrime();
		while (p %g == 0)
			p = generateNewLargePrime();

	}
}
// Implementation of a GF(p) field
#ifndef __POL_RING_HPP
#define __POL_RING_HPP

#include "types.hpp"
#include "exceptions.hpp"

#include <vector>
#include <algorithm>        // find_if
#include <utility>          // pair, make_pair
#include <string>           // to_string

template<typename Fxelem, typename Felem>
class PolynomialRing{
    public:
        // Inmersion from the base field
        PolynomialRing(const Felem &e): _v(std::vector<Felem>({e})){}

        PolynomialRing(const std::vector<Felem> &v): _v(v){
            if(v.size()==0)
                throw EEmptyVector("The vector used to define the element of R[X] is empty.");
            // Remove trailing zeros
            this->removeTrailingZeros();
            Felem aux = this->lc();
            for(auto &e : v)
                if(!compatible(aux, e))
                    throw ENotCompatible("Not all the elements in the array are in the same field.");
        }

        Fxelem & operator=(const Fxelem &rhs){
            if(&rhs != this){
                if(!compatible(this->lc(), rhs.lc()))
                    throw ENotCompatible("Asignation failed. The vectors "+ to_string(static_cast<Fxelem&>(*this))+ " and " + to_string(rhs) + " are not in the same ring.");
                _v = rhs._v;
            }
            return static_cast<Fxelem&>(*this);
        }

        bool operator==(const Fxelem &rhs)const{
            return _v == rhs._v;
        }

        bool operator!=(const Fxelem &rhs)const{
            return _v != rhs._v;
        }

        Fxelem & operator+=(const Fxelem &rhs){
            if(!compatible(static_cast<Fxelem&>(*this),rhs))
                throw EOperationUnsupported(
                        "Polynomials not in the same ring. Error when adding the polynomials " + to_string(static_cast<Fxelem&>(*this)) +
                        " and " + to_string(rhs) +  ".");
            auto v1 = _v.begin();
            auto v2 = rhs._v.begin();
            while(v1 != _v.end() && v2 != rhs._v.end()){
                *v1 += *v2;
                ++v1; ++v2;
            }
            while(v2 != rhs._v.end()){
                _v.push_back(*v2);
                ++v2;
            }
            this->removeTrailingZeros();
            return static_cast<Fxelem&>(*this);
        }

        const Fxelem operator+(const Fxelem &rhs) const{
            // We do not check if they are in the same field since
            // that will be done in the += operator
            return Fxelem(static_cast<const Fxelem&>(*this)) += rhs;
        }

        const Fxelem operator-() const{
            std::vector<Felem> ret(_v.size(),getZero(this->lc()));

            for(size_t i=0;i<_v.size();++i)
                ret[i]=Felem(-_v[i]);
            return Fxelem(ret);
        }

        Fxelem & operator-=(const Fxelem &rhs){
            // We do not check if they are in the same field since
            // that will be done in the += operator
            return (static_cast<Fxelem&>(*this) +=(-rhs));
        }

        const Fxelem operator-(const Fxelem &rhs) const{
            return Fxelem(static_cast<const Fxelem&>(*this)) -= rhs;
        }

        Fxelem & operator*=(const Fxelem &rhs){
            if(!compatible(static_cast<Fxelem&>(*this),rhs))
                throw EOperationUnsupported(
                        "Polynomials not in the same ring. Error when multiplying the polynomials " + to_string(static_cast<Fxelem&>(*this)) +
                        " and " + to_string(rhs) +  ".");

            std::vector<Felem> ret(rhs._v.size()+_v.size()-1,getZero(this->lc()));
            for(size_t i=0;i<_v.size();++i)
                for(size_t j=0;j<rhs._v.size();++j){
                    ret[i+j]+=_v[i]*rhs._v[j];
                }
            _v = ret;
            return static_cast<Fxelem&>(*this);
        }

        const Fxelem operator*(const Fxelem &rhs) const{
            // We do not check if they are in the same field since
            // that will be done in the *= operator
            return Fxelem(static_cast<const Fxelem&>(*this)) *= rhs;
        }

        // Implements long polynomial division
        // Return quotient and reminder in first and second respectively
        std::pair<Fxelem,Fxelem> div2(const Fxelem &divisor){
            if(!compatible(static_cast<Fxelem&>(*this),divisor))
                throw EOperationUnsupported(
                        "Polynomials not in the same ring. Error when dividing the polynomials " + to_string(static_cast<Fxelem&>(*this)) +
                        " and " + to_string(divisor) +  ".");

            if(divisor.deg()==0 && divisor._v[0] == 0)
                throw EOperationUnsupported("Error. Cannot divide by the polynomial 0");
            if(this->deg() < divisor.deg())
                return std::make_pair(Fxelem(getZero(this->lc())), static_cast<Fxelem&>(*this));

            if(divisor.deg() == 0){
                Fxelem quot = static_cast<Fxelem&>(*this);
				Fxelem rem(static_cast<Fxelem&>(*this));
                for(auto &e : quot._v){
                    e/=divisor.lc();
                }
                return std::make_pair(quot, Fxelem(getZero(this->lc())));
            }

            Fxelem quot(getZero(this->lc()));
            Fxelem rem(static_cast<Fxelem&>(*this));

            while(rem.deg() >= divisor.deg()){
                std::vector<Felem> paddingZeros(rem.deg() - divisor.deg(), getZero(this->lc()));

                paddingZeros.push_back(rem.lc()/divisor.lc());
                Fxelem monDiv (paddingZeros);
                quot += monDiv;
                rem -= monDiv*divisor;
            }
            rem.removeTrailingZeros();

            return std::make_pair(quot,rem);
        }

        Fxelem & operator/=(const Fxelem &rhs){
            // We do not check if they are in the same field since
            // that will be done in the div2 method
            *this = this->div2(rhs).first;
            return static_cast<Fxelem&>(*this);
        }

        const Fxelem operator/(const Fxelem &rhs) const{
            // We do not check if they are in the same field since
            // that will be done in the div2 method

            return Fxelem(static_cast<const Fxelem&>(*this)) /= rhs;
        }

        Fxelem & operator%=(const Fxelem &rhs){
            // We do not check if they are in the same field since
            // that will be done in the div2 method
            *this = this->div2(rhs).second;
            return static_cast<Fxelem&>(*this);
        }

        const Fxelem operator%(const Fxelem &rhs) const{
            // We do not check if they are in the same field since
            // that will be done in the /= operator

            return Fxelem(static_cast<const Fxelem&>(*this)) %= rhs;
        }

        const Felem & operator[](int i) const {return _v[i];}
        Felem & operator[](int i) {return _v[i];}

        // Leading coefficient
        Felem lc()const{return _v.back();}

        // Degree of the polynomial
        unsigned int deg()const{return _v.size()-1;}

        // Normal form of the polynomial. It ensures the unicity of gdc for example
        friend const Fxelem normalForm(const Fxelem &e){ return e/unit(e); }

        friend std::string to_string(const Fxelem &f){
            std::string s = "";
            if(f._v.size() == 1)
                return to_string(f._v[0]);
            if(f._v.size() == 2){
                if(f._v[1] != 1)
                    s = to_string(f._v[1]);
                s += "x";
                if(f._v[0] != 0)
                    s += "+" + to_string(f._v[0]);
                return s;
            }
            if(f._v.back() != 1)
                s += to_string(f._v.back());
            s +=  "x^" + std::to_string(f._v.size()-1);

            for(int i=f._v.size()-2;i>=2;--i){
                if(f._v[i] != 0){
                    s+="+";
                    if(f._v[i] != 1)
                        s += to_string(f._v[i]);
                    s += "x^" + std::to_string(i);
                }
            }
            if(f._v[1] != 0){
                s += "+";
                if(f._v[1] != 1)
                    s += to_string(f._v[1]);
                s += "x";
            }
            if(f._v[0] != 0)
                s += "+"+ to_string(f._v[0]);
            return s;
        }

        friend std::ostream& operator<<(std::ostream& os, const Fxelem &f){
            return os << to_string(f);
        }

    private:
        void removeTrailingZeros(){
            auto zero = getZero(this->lc());
            _v.erase(
                    std::find_if(
                        _v.rbegin(),
                        _v.rend(),
                        std::bind1st(std::not_equal_to<Felem>(), zero)).base(),
                    _v.end());
            // In case it was the polynomial equal to zero
            if(_v.size()==0)
                _v.push_back(zero);
        }


        std::vector<Felem> _v;
};


#endif //  __POL_RING_HPP
#ifndef __TYPES_HPP
#define __TYPES_HPP

#include<boost/multiprecision/gmp.hpp>

typedef long long ll;
typedef unsigned long long ull;
typedef boost::multiprecision::mpz_int big_int;



#endif // __TYPES_HPP
#include <string>

#include "zelem.hpp"
// Types inlcuded in zelem.hpp

bool compatible(big_int lhs, big_int rhs){
    return true;
}
const big_int unit(big_int e){
    return e >= 0 ? (big_int)1 : (big_int)-1;
}
const big_int normalForm(big_int e){ return e/unit(e);}

std::string to_string(big_int e){return std::to_string(e);}

big_int getZero(big_int e){return (big_int)0;}
big_int getOne(big_int e){return (big_int)1;}
#ifndef __ZELEM_HPP
#define __ZELEM_HPP

#include <string>
#include "types.hpp"

std::string to_string(big_int e);
bool compatible(big_int lhs, big_int rhs);
const big_int unit(big_int e);
const big_int normalForm(big_int e);
big_int getZero(big_int e);
big_int getOne(big_int e);

#endif // __ZELEM_HPP
#include <vector>

#include "zxelem.hpp"
// types.hpp included en zxelem.hpp

Zxelem::Zxelem(const big_int & e) : PolynomialRing<Zxelem, big_int>(e){}
Zxelem::Zxelem(const std::vector<big_int> & v) : PolynomialRing<Zxelem, big_int>(v){}


const big_int unit(const Zxelem &e){
    return unit(e.lc());
}



// Implementation of a GF(p) field
#ifndef __ZXELEM_HPP
#define __ZXELEM_HPP

#include "types.hpp"
#include "zelem.hpp"    // Auxliary functions
#include "polRing.hpp"


class Zxelem : public PolynomialRing<Zxelem, big_int>{
    public:
        Zxelem(const big_int & e);
        Zxelem(const std::vector<big_int> & v);
};

const big_int unit(const Zxelem &e);

#endif
