/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::squareFreeFF(Fxelem) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:470:87:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:90:26: error: no match for ‘operator[]’ (operand types are ‘alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                     if (c[j] != 0)
                          ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::squareFreeFF(Fxelem) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:470:87:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:90:26: error: no match for ‘operator[]’ (operand types are ‘alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                     if (c[j] != 0)
                          ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:91:53: error: no match for ‘operator[]’ (operand types are ‘alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                         rootPOfC.push_back(fastPow(c[j], exponent));
                                                     ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:91:53: error: no match for ‘operator[]’ (operand types are ‘alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                         rootPOfC.push_back(fastPow(c[j], exponent));
                                                     ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: error: no match for ‘operator*=’ (operand types are ‘unsigned int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                     pair.second *= p;
                                 ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: error: no match for ‘operator*=’ (operand types are ‘unsigned int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                     pair.second *= p;
                                 ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: note: candidate: operator*=(unsigned int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: note: candidate: operator*=(unsigned int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: error: no match for ‘operator+=’ (operand types are ‘int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
             for (int j = 0; j <= a.deg(); j += p)
                                             ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: error: no match for ‘operator+=’ (operand types are ‘int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
             for (int j = 0; j <= a.deg(); j += p)
                                             ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: note: candidate: operator+=(int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: note: candidate: operator+=(int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: error: no match for ‘operator*=’ (operand types are ‘unsigned int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 pair.second *= p;
                             ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: note: candidate: operator*=(unsigned int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: error: no match for ‘operator*=’ (operand types are ‘unsigned int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 pair.second *= p;
                             ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: note: candidate: operator*=(unsigned int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘std::vector<Fxelem> alcp::splitFactorsDD(const Fxelem&, int) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:474:79:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:18: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                  ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘std::vector<Fxelem> alcp::splitFactorsDD(const Fxelem&, int) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:474:79:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:18: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                  ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:25: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’)
                 r[j] = r[j - 1] - aux * pol[j];
                         ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:25: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’)
                 r[j] = r[j - 1] - aux * pol[j];
                         ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:44: error: no match for ‘operator[]’ (operand types are ‘const alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                                            ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:44: error: no match for ‘operator[]’ (operand types are ‘const alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                                            ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::squareFreeFF(Fxelem) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:484:87:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:90:26: error: no match for ‘operator[]’ (operand types are ‘alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                     if (c[j] != 0)
                          ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::squareFreeFF(Fxelem) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:484:87:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:90:26: error: no match for ‘operator[]’ (operand types are ‘alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                     if (c[j] != 0)
                          ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:91:53: error: no match for ‘operator[]’ (operand types are ‘alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                         rootPOfC.push_back(fastPow(c[j], exponent));
                                                     ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:91:53: error: no match for ‘operator[]’ (operand types are ‘alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                         rootPOfC.push_back(fastPow(c[j], exponent));
                                                     ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: error: no match for ‘operator*=’ (operand types are ‘unsigned int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                     pair.second *= p;
                                 ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: error: no match for ‘operator*=’ (operand types are ‘unsigned int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                     pair.second *= p;
                                 ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: note: candidate: operator*=(unsigned int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: note: candidate: operator*=(unsigned int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:98:33: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: error: no match for ‘operator+=’ (operand types are ‘int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
             for (int j = 0; j <= a.deg(); j += p)
                                             ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: error: no match for ‘operator+=’ (operand types are ‘int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
             for (int j = 0; j <= a.deg(); j += p)
                                             ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: note: candidate: operator+=(int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: note: candidate: operator+=(int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:112:45: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: error: no match for ‘operator*=’ (operand types are ‘unsigned int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 pair.second *= p;
                             ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: note: candidate: operator*=(unsigned int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: error: no match for ‘operator*=’ (operand types are ‘unsigned int’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 pair.second *= p;
                             ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: note: candidate: operator*=(unsigned int&, int) <built-in>
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:121:29: note:   no known conversion for argument 2 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘int’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘std::vector<Fxelem> alcp::splitFactorsDD(const Fxelem&, int) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:488:79:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:18: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                  ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘std::vector<Fxelem> alcp::splitFactorsDD(const Fxelem&, int) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:488:79:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:18: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                  ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:25: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’)
                 r[j] = r[j - 1] - aux * pol[j];
                         ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = sIn file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:25: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’)
                 r[j] = r[j - 1] - aux * pol[j];
                         ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:44: error: no match for ‘operator[]’ (operand types are ‘const alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                                            ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: ntd::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:249:44: error: no match for ‘operator[]’ (operand types are ‘const alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                                            ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
ote:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘alcp::matrix<typename Fxelem::Felem> alcp::formMatrix(const Fxelem&) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; alcp::matrix<typename Fxelem::Felem> = std::vector<std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >, std::allocator<std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > > > >; typename Fxelem::Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:146:30:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::partialFactorDD(Fxelem) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:472:92:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:18: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                  ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘alcp::matrix<typename Fxelem::Felem> alcp::formMatrix(const Fxelem&) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; alcp::matrix<typename Fxelem::Felem> = std::vector<std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >, std::allocator<std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > > > >; typename Fxelem::Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:146:30:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::partialFactorDD(Fxelem) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:472:92:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:18: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                  ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:25: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’)
                 r[j] = r[j - 1] - aux * pol[j];
                         ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:25: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’)
                 r[j] = r[j - 1] - aux * pol[j];
                         ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:44: error: no match for ‘operator[]’ (operand types are ‘const alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                                            ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:44: error: no match for ‘operator[]’ (operand types are ‘const alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                                            ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp: In instantiation of ‘std::vector<alcp::Fpelem<Integer> > alcp::Fp<Integer>::getElems() const [with Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:419:17:   required from ‘std::vector<Fxelem> alcp::berlekamp_simple(const Fxelem&) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:478:74:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:49:20: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’)
                 ret[i] = this->get(i);
                    ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp: In instantiation of ‘std::vector<alcp::Fpelem<Integer> > alcp::Fp<Integer>::getElems() const [with Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:419:17:   required from ‘std::vector<Fxelem> alcp::berlekamp_simple(const Fxelem&) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:478:74:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:49:20: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’)
                 ret[i] = this->get(i);
                    ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘alcp::matrix<typename Fxelem::Felem> alcp::formMatrix(const Fxelem&) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; alcp::matrix<typename Fxelem::Felem> = std::vector<std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >, std::allocator<std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > > > >; typename Fxelem::Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:146:30:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::partialFactorDD(Fxelem) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:486:92:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:18: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                  ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp: In instantiation of ‘alcp::matrix<typename Fxelem::Felem> alcp::formMatrix(const Fxelem&) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; alcp::matrix<typename Fxelem::Felem> = std::vector<std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >, std::allocator<std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > > > >; typename Fxelem::Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:146:30:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::partialFactorDD(Fxelem) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:486:92:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:18: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                  ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:25: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’)
                 r[j] = r[j - 1] - aux * pol[j];
                         ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:25: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’)
                 r[j] = r[j - 1] - aux * pol[j];
                         ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:44: error: no match for ‘operator[]’ (operand types are ‘const alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                                            ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::subtract_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >, int, void, void>}’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:310:44: error: no match for ‘operator[]’ (operand types are ‘const alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >’ and ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’)
                 r[j] = r[j - 1] - aux * pol[j];
                                            ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/zxelem.hpp:9:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note: candidate: const Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) const [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         const Felem &operator[](size_t i) const { return _v[i]; }
                      ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:172:22: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note: candidate: Felem& alcp::PolynomialRing<Fxelem, Felem>::operator[](size_t) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; size_t = long unsigned int]
         Felem &operator[](size_t i) { return _v[i]; }
                ^
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:174:16: note:   no known conversion for argument 1 from ‘alcp::big_int {aka boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >}’ to ‘size_t {aka long unsigned int}’
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp: In instantiation of ‘std::vector<alcp::Fqelem<Integer> > alcp::Fq<Integer>::getElems() const [with Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:419:17:   required from ‘std::vector<Fxelem> alcp::berlekamp_simple(const Fxelem&) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:492:74:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:59:20: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’)
                 ret[i++] = this->get(Fpxelem<Integer>(act));
                    ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp: In instantiation of ‘std::vector<alcp::Fqelem<Integer> > alcp::Fq<Integer>::getElems() const [with Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:419:17:   required from ‘std::vector<Fxelem> alcp::berlekamp_simple(const Fxelem&) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:492:74:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:59:20: error: no match for ‘operator[]’ (operand types are ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’)
                 ret[i++] = this->get(Fpxelem<Integer>(act));
                    ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note: candidate: std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::reference = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:779:7: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note: candidate: std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; _Alloc = std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > >; std::vector<_Tp, _Alloc>::const_reference = const alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]
       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
       ^
/usr/include/c++/5.3.0/bits/stl_vector.h:794:7: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >::size_type {aka long unsigned int}’
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:8:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp: In instantiation of ‘void alcp::QuotientRing<FelemBase, Quotient, Integer>::checkInSameField(const alcp::QuotientRing<FelemBase, Quotient, Integer>&, std::__cxx11::string&&) const [with FelemBase = alcp::Fpelem; Quotient = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >; Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >; std::__cxx11::string = std::__cxx11::basic_string<char>]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:39:37:   required from ‘alcp::QuotientRing<FelemBase, Quotient, Integer>& alcp::QuotientRing<FelemBase, Quotient, Integer>::operator=(const alcp::QuotientRing<FelemBase, Quotient, Integer>&) [with FelemBase = alcp::Fpelem; Quotient = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >; Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:74:11:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::partialFactorDD(Fxelem) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:472:92:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:229:26: error: no matching function for call to ‘to_string(const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >&)’
                 to_string(_num) + " in " +
                          ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:8:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp: In instantiation of ‘void alcp::QuotientRing<FelemBase, Quotient, Integer>::checkInSameField(const alcp::QuotientRing<FelemBase, Quotient, Integer>&, std::__cxx11::string&&) const [with FelemBase = alcp::Fpelem; Quotient = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >; Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >; std::__cxx11::string = std::__cxx11::basic_string<char>]’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:39:37:   required from ‘alcp::QuotientRing<FelemBase, Quotient, Integer>& alcp::QuotientRing<FelemBase, Quotient, Integer>::operator=(const alcp::QuotientRing<FelemBase, Quotient, Integer>&) [with FelemBase = alcp::Fpelem; Quotient = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >; Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:74:11:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::partialFactorDD(Fxelem) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:472:92:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:229:26: error: no matching function for call to ‘to_string(const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >&)’
                 to_string(_num) + " in " +
                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(int)
   to_string(int __val)
   ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(int)
   to_string(int __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘int’
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(unsigned int)
   to_string(unsigned __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long int)
   to_string(long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long unsigned int)
   to_string(unsigned long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long int)
   to_string(long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long unsigned int)
   to_string(unsigned long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘int’
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(unsigned int)
   to_string(unsigned __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long int)
   to_string(long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long unsigned int)
   to_string(unsigned long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long int)
   to_string(long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long unsigned int)
   to_string(unsigned long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(float)
   to_string(float __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘float’
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(double)
   to_string(double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘double’
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long double)
   to_string(long double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long double’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(float)
   to_string(float __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘float’
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(double)
   to_string(double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘double’
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long double)
   to_string(long double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long double’
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:8:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:231:36: error: no matching function for call to ‘to_string(const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >&)’
                 " and " + to_string(rhs._num) + " in F" +
                                    ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:8:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:231:36: error: no matching function for call to ‘to_string(const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >&)’
                 " and " + to_string(rhs._num) + " in F" +
                                    ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(int)
   to_string(int __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘int’
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(unsigned int)
   to_string(unsigned __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long int)
   to_string(long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long unsigned int)
   to_string(unsigned long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long int)
   to_string(long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long unsigned int)
   to_string(unsigned long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(float)
   to_string(float __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘float’
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(int)
   to_string(int __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘int’
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(unsigned int)
   to_string(unsigned __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long int)
   to_string(long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long unsigned int)
   to_string(unsigned long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long int)
   to_string(long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long unsigned int)
   to_string(unsigned long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(float)
   to_string(float __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘float’
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(double)
   to_string(double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘double’
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long double)
   to_string(long double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long double’
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(double)
   to_string(double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘double’
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long double)
   to_string(long double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long double’
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:8:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp: In instantiation of ‘std::__cxx11::string alcp::to_string(const Felem&)’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:202:33:   required from ‘std::__cxx11::string alcp::to_string(const alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&)’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:40:74:   required from ‘alcp::PolynomialRing<Fxelem, Felem>& alcp::PolynomialRing<Fxelem, Felem>::operator=(const alcp::PolynomialRing<Fxelem, Felem>&) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:18:11:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::squareFreeFF(Fxelem) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:470:87:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:212:29: error: no matching function for call to ‘to_string(const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >&)’
             return to_string(e._num);
                             ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(int)
   to_string(int __val)
   ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:8:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp: In instantiation of ‘std::__cxx11::string alcp::to_string(const Felem&)’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:202:33:   required from ‘std::__cxx11::string alcp::to_string(const alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&)’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/polRing.hpp:40:74:   required from ‘alcp::PolynomialRing<Fxelem, Felem>& alcp::PolynomialRing<Fxelem, Felem>::operator=(const alcp::PolynomialRing<Fxelem, Felem>&) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Felem = alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:18:11:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::squareFreeFF(Fxelem) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:470:87:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:212:29: error: no matching function for call to ‘to_string(const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >&)’
             return to_string(e._num);
                             ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(int)
   to_string(int __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘int’
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(unsigned int)
   to_string(unsigned __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long int)
   to_string(long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long unsigned int)
   to_string(unsigned long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long int)
   to_string(long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long unsigned int)
   to_string(unsigned long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(float)
   to_string(float __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘float’
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(double)
   to_string(double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘double’
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long double)
   to_string(long double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long double’
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘int’
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(unsigned int)
   to_string(unsigned __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long int)
   to_string(long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long unsigned int)
   to_string(unsigned long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long int)
   to_string(long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long unsigned int)
   to_string(unsigned long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(float)
   to_string(float __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘float’
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(double)
   to_string(double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘double’
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long double)
   to_string(long double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note:   no known conversion for argument 1 from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long double’
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp: In instantiation of ‘std::__cxx11::string alcp::to_string(const alcp::Fq<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&)’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:230:26:   required from ‘void alcp::QuotientRing<FelemBase, Quotient, Integer>::checkInSameField(const alcp::QuotientRing<FelemBase, Quotient, Integer>&, std::__cxx11::string&&) const [with FelemBase = alcp::Fqelem; Quotient = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >; std::__cxx11::string = std::__cxx11::basic_string<char>]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:39:37:   required from ‘alcp::QuotientRing<FelemBase, Quotient, Integer>& alcp::QuotientRing<FelemBase, Quotient, Integer>::operator=(const alcp::QuotientRing<FelemBase, Quotient, Integer>&) [with FelemBase = alcp::Fqelem; Quotient = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:97:11:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::partialFactorDD(Fxelem) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:486:92:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:71:35: error: no matching function for call to ‘to_string(boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >)’
             return "F" + to_string(e.getP()) + "^" + to_string(e.getM());
                                   ^
In file included from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp: In instantiation of ‘std::__cxx11::string alcp::to_string(const alcp::Fq<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >&)’:
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:230:26:   required from ‘void alcp::QuotientRing<FelemBase, Quotient, Integer>::checkInSameField(const alcp::QuotientRing<FelemBase, Quotient, Integer>&, std::__cxx11::string&&) const [with FelemBase = alcp::Fqelem; Quotient = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >; std::__cxx11::string = std::__cxx11::basic_string<char>]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/quotientRing.hpp:39:37:   required from ‘alcp::QuotientRing<FelemBase, Quotient, Integer>& alcp::QuotientRing<FelemBase, Quotient, Integer>::operator=(const alcp::QuotientRing<FelemBase, Quotient, Integer>&) [with FelemBase = alcp::Fqelem; Quotient = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >; Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:97:11:   required from ‘std::vector<std::pair<Fxelem, unsigned int> > alcp::partialFactorDD(Fxelem) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:486:92:   required from here
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:71:35: error: no matching function for call to ‘to_string(boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >)’
             return "F" + to_string(e.getP()) + "^" + to_string(e.getM());
                                   ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(int)
   to_string(int __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘int’
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(unsigned int)
   to_string(unsigned __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long int)
   to_string(long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long unsigned int)
   to_string(unsigned long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long int)
   to_string(long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long unsigned int)
   to_string(unsigned long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(float)
   to_string(float __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘float’
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(double)
   to_string(double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘double’
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long double)
   to_string(long double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long double’
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(int)
   to_string(int __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5301:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘int’
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(unsigned int)
   to_string(unsigned __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5306:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long int)
   to_string(long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5312:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long unsigned int)
   to_string(unsigned long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5317:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long int)
   to_string(long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5323:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long int’
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long long unsigned int)
   to_string(unsigned long long __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5329:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long long unsigned int’
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(float)
   to_string(float __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5335:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘float’
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(double)
   to_string(double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5344:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘double’
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note: candidate: std::__cxx11::string std::__cxx11::to_string(long double)
   to_string(long double __val)
   ^
/usr/include/c++/5.3.0/bits/basic_string.h:5353:3: note:   no known conversion for argument 1 from ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >’ to ‘long double’
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp: In instantiation of ‘bool boost::multiprecision::default_ops::check_in_range(const T&) [with R = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; T = long double]’:
/usr/include/boost/multiprecision/detail/default_ops.hpp:867:24:   required from ‘void boost::multiprecision::default_ops::eval_convert_to(R*, const B&) [with R = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; B = boost::multiprecision::backends::cpp_int_backend<>]’
/usr/include/boost/multiprecision/number.hpp:585:22:   required from ‘void boost::multiprecision::number<Backend, ExpressionTemplates>::convert_to_imp(T*) const [with T = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/usr/include/boost/multiprecision/number.hpp:601:21:   required from ‘T boost::multiprecision::number<Backend, ExpressionTemplates>::convert_to() const [with T = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/usr/include/boost/multiprecision/number.hpp:629:43:   required from ‘boost::multiprecision::number<Backend, ExpressionTemplates>::operator T() const [with T = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:47:48:   required from ‘std::vector<alcp::Fpelem<Integer> > alcp::Fp<Integer>::getElems() const [with Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:419:17:   required from ‘std::vector<Fxelem> alcp::berlekamp_simple(const Fxelem&) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:478:74:   required from here
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: error: no match for ‘operator>’ (operand types are ‘const long double’ and ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost:In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp: In instantiation of ‘bool boost::multiprecision::default_ops::check_in_range(const T&) [with R = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; T = long double]’:
/usr/include/boost/multiprecision/detail/default_ops.hpp:867:24:   required from ‘void boost::multiprecision::default_ops::eval_convert_to(R*, const B&) [with R = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; B = boost::multiprecision::backends::cpp_int_backend<>]’
/usr/include/boost/multiprecision/number.hpp:585:22:   required from ‘void boost::multiprecision::number<Backend, ExpressionTemplates>::convert_to_imp(T*) const [with T = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/usr/include/boost/multiprecision/number.hpp:601:21:   required from ‘T boost::multiprecision::number<Backend, ExpressionTemplates>::convert_to() const [with T = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/usr/include/boost/multiprecision/number.hpp:629:43:   required from ‘boost::multiprecision::number<Backend, ExpressionTemplates>::operator T() const [with T = std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:47:48:   required from ‘std::vector<alcp::Fpelem<Integer> > alcp::Fp<Integer>::getElems() const [with Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:419:17:   required from ‘std::vector<Fxelem> alcp::berlekamp_simple(const Fxelem&) [with Fxelem = alcp::Fpxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:478:74:   required from here
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: error: no match for ‘operator>’ (operand types are ‘const long double’ and ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’)
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:311:13: note: candidate: template<class Backend, boost::multiprecision::expression_template_option ExpressionTemplates, class Backend2, boost::multiprecision::expression_template_option ExpressionTemplates2> bool boost::multiprecision::operator>(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::number<T2, ExpressionTemplates2>&)
 inline bool operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
             ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:311:13: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:319:4: note: candidate: template<class Backend, boost::multiprecision::expression_template_option ExpressionTemplates, class Arithmetic> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<boost::multiprecision::number<Backend, ExpressionTemplates>, Val>::value, bool>::type boost::multiprecision::operator>(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const Arithmetic&)
    operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:319:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos:multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’)
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:311:13: note: candidate: template<class Backend, boost::multiprecision::expression_template_option ExpressionTemplates, class Backend2, boost::multiprecision::expression_template_option ExpressionTemplates2> bool boost::multiprecision::operator>(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::number<T2, ExpressionTemplates2>&)
 inline bool operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
             ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:311:13: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:319:4: note: candidate: template<class Backend, boost::multiprecision::expression_template_option ExpressionTemplates, class Arithmetic> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<boost::multiprecision::number<Backend, ExpressionTemplates>, Val>::value, bool>::type boost::multiprecision::operator>(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const Arithmetic&)
    operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:319:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:327:4: note: candidate: template<class Arithmetic, class Backend, boost::multiprecision::expression_template_option ExpressionTemplates> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<boost::multiprecision::number<T2, ExpressionTemplates>, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const Arithmetic&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:327:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ is not derived from ‘const boost::multiprecision::number<T2, ExpressionTemplates>’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:335:4: note: candidate: template<class Arithmetic, class Tag, class A1, class A2, class A3, class A4> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const Arithmetic&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:335:4: note:   template argument deduction/substitu/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:327:4: note: candidate: template<class Arithmetic, class Backend, boost::multiprecision::expression_template_option ExpressionTemplates> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<boost::multiprecision::number<T2, ExpressionTemplates>, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const Arithmetic&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:327:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ is not derived from ‘const boost::multiprecision::number<T2, ExpressionTemplates>’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:335:4: note: candidate: template<class Arithmetic, class Tag, class A1, class A2, class A3, class A4> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const Arithmetic&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:335:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:345:4: note: candidate: template<class Tag, class A1, class A2, class A3, class A4, class Arithmetic> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const Arithmetic&)
    operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:345:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:355:4: note: candidate: template<class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b> typename boost::enable_if<boost::is_same<typenamtion failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   ‘std::vector<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fpelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:345:4: note: candidate: template<class Tag, class A1, class A2, class A3, class A4, class Arithmetic> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const Arithmetic&)
    operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:345:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:355:4: note: candidate: template<class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b> typename boost::enable_if<boost::is_same<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, typename boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type boost::multiprecision::operator>(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:355:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/map:62:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:11,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/usr/include/c++/5.3.0/bits/stl_multimap.h:1005:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator>(const std::multimap<_Key, _Tp, _Compare, _Alloc>&, const std::multimap<_Key, _Tp, _Compare, _Alloc>&)
     operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_multimap.h:1005:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::multimap<_Key, _Tp, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/map:61:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:11,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/usr/include/c++/5.3.0/bits/stl_map.h:1104:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator>(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key, _Tp, _Compare, _Alloc>&)
     operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5e boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, typename boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type boost::multiprecision::operator>(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:355:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/map:62:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:11,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/usr/include/c++/5.3.0/bits/stl_multimap.h:1005:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator>(const std::multimap<_Key, _Tp, _Compare, _Alloc>&, const std::multimap<_Key, _Tp, _Compare, _Alloc>&)
     operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_multimap.h:1005:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::multimap<_Key, _Tp, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/map:61:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:11,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/usr/include/c++/5.3.0/bits/stl_map.h:1104:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator>(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key, _Tp, _Compare, _Alloc>&)
     operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_map.h:1104:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::map<_Key, _Tp, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:62:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_multiset.h:856:5: note: candidate: template<class _Key, class _Compare, class _Alloc> bool std::operator>(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key, _Compare, _Alloc>&)
     operator>(const multiset<_Key,_Compare,_Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_multiset.h:856:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::multiset<_Key, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:61:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_set.h:873:5: note: candidate: template<class _Key, class _Compare, class _Alloc> bool std::operator>(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key, _Compare, _Alloc>&)
     operator>(const set<_Key, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_set.h:873:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq..3.0/bits/stl_map.h:1104:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::map<_Key, _Tp, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:62:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_multiset.h:856:5: note: candidate: template<class _Key, class _Compare, class _Alloc> bool std::operator>(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key, _Compare, _Alloc>&)
     operator>(const multiset<_Key,_Compare,_Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_multiset.h:856:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::multiset<_Key, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:61:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_set.h:873:5: note: candidate: template<class _Key, class _Compare, class _Alloc> bool std::operator>(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key, _Compare, _Alloc>&)
     operator>(const set<_Key, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_set.h:873:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::set<_Key, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:60:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_tree.h:1300:5: note: candidate: template<class _Key, class _Val, class _KeyOfValue, class _Compare, class _Alloc> bool std::operator>(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&, const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)
     operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_tree.h:1300:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:414:5: note: candidate: template<class _Tp> bool std::operator>(std::nullptr_t, const std::shared_ptr<_Tp1>&)
     operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:414:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /medcpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::set<_Key, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:60:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_tree.h:1300:5: note: candidate: template<class _Key, class _Val, class _KeyOfValue, class _Compare, class _Alloc> bool std::operator>(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&, const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)
     operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_tree.h:1300:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:414:5: note: candidate: template<class _Tp> bool std::operator>(std::nullptr_t, const std::shared_ptr<_Tp1>&)
     operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:414:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:409:5: note: candidate: template<class _Tp> bool std::operator>(const std::shared_ptr<_Tp1>&, std::nullptr_t)
     operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:409:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::shared_ptr<_Tp1>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Dia/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:409:5: note: candidate: template<class _Tp> bool std::operator>(const std::shared_ptr<_Tp1>&, std::nullptr_t)
     operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:409:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::shared_ptr<_Tp1>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:403:5: note: candidate: template<class _Tp1, class _Tp2> bool std::operator>(const std::shared_ptr<_Tp1>&, const std::shared_ptr<_Tp2>&)
     operator>(const shared_ptr<_Tp1>& __a,
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:403:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::shared_ptr<_Tp1>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1261:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)
     operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1261:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hppocumentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:403:5: note: candidate: template<class _Tp1, class _Tp2> bool std::operator>(const std::shared_ptr<_Tp1>&, const std::shared_ptr<_Tp2>&)
     operator>(const shared_ptr<_Tp1>& __a,
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:403:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::shared_ptr<_Tp1>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1261:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)
     operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1261:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1256:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)
     operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1256:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__shared_ptr<_Tp, _Lp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1250:5: note: candidate: template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)
     operator>(const __shared_ptr<_Tp1, _Lp>& __a,
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1250:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1256:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)
     operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1256:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__shared_ptr<_Tp, _Lp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1250:5: note: candidate: template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)
     operator>(const __shared_ptr<_Tp1, _Lp>& __a,
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1250:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__shared_ptr<_Tp1, _Lp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:711:5: note: candidate: template<class _Tp, class _Dp> bool std::operator>(std::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)
     operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:711:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:705:5: note: candidate: template<class _Tp, class _Dp> bool std::operator>(const std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)
     operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:705:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__shared_ptr<_Tp1, _Lp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:711:5: note: candidate: template<class _Tp, class _Dp> bool std::operator>(std::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)
     operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:711:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:705:5: note: candidate: template<class _Tp, class _Dp> bool std::operator>(const std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)
     operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:705:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:699:5: note: candidate: template<class _Tp, class _Dp, class _Up, class _Ep> bool std::operator>(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up, _Ep>&)
     operator>(const unique_ptr<_Tp, _Dp>& __x,
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:699:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:699:5: note: candidate: template<class _Tp, class _Dp, class _Up, class _Ep> bool std::operator>(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up, _Ep>&)
     operator>(const unique_ptr<_Tp, _Dp>& __x,
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:699:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/unique_ptr.h:37:0,
                 from /usr/include/c++/5.3.0/bits/locale_conv.h:41,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/tuple:947:5: note: candidate: template<class ... _TElements, class ... _UElements> constexpr bool std::operator>(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator>(const tuple<_TElements...>& __t,
     ^
In file included from /usr/include/c++/5.3.0/bits/unique_ptr.h:37:0,
                 from /usr/include/c++/5.3.0/bits/locale_conv.h:41,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/tuple:947:5: note: candidate: template<class ... _TElements, class ... _UElements> constexpr bool std::operator>(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator>(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/5.3.0/tuple:947:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::tuple<_Elements ...>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
/usr/include/c++/5.3.0/tuple:947:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::tuple<_Elements ...>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/tuple:39:0,
                 from /usr/include/c++/5.3.0/bits/unique_ptr.h:37,
                 from /usr/include/c++/5.3.0/bits/locale_conv.h:41,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/array:258:5: note: candidate: template<class _Tp, long unsigned int _Nm> bool std::operator>(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/5.3.0/array:258:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::array<_Tp, _Nm>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/tuple:39:0,
                 from /usr/include/c++/5.3.0/bits/unique_ptr.h:37,
                 from /usr/include/c++/5.3.0/bits/locale_conv.h:41,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/array:258:5: note: candidate: template<class _Tp, long unsigned int _Nm> bool std::operator>(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/5.3.0/array:258:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::array<_Tp, _Nm>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5050:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator>(const _CharT* __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5050:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const _CharT*’ and ‘long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5038:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5038:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5026:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5026:5: note:  In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5050:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator>(const _CharT* __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5050:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const _CharT*’ and ‘long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5038:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5038:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5026:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5026:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:1541:5: note: candidate: template<class _Tp, class _Alloc> bool std::operator>(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/5.3.0/bits/stl_vector.h:1541:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::vector<_Tp, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
 template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:1541:5: note: candidate: template<class _Tp, class _Alloc> bool std::operator>(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/5.3.0/bits/stl_vector.h:1541:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::vector<_Tp, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:1119:5: note: candidate: template<class _Iterator> bool std::operator>(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator>(const move_iterator<_Iterator>& __x,
     ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:1119:5: note: candidate: template<class _Iterator> bool std::operator>(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator>(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:1119:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::move_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:1113:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator>(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator>(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:1113:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::move_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:360:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator>(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator>(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:1119:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::move_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:1113:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator>(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator>(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:1113:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::move_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:360:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator>(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator>(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:360:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::reverse_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:310:5: note: candidate: template<class _Iterator> bool std::operator>(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator>(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:310:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::reverse_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:360:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::reverse_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:310:5: note: candidate: template<class _Iterator> bool std::operator>(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator>(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:310:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::reverse_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:64:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_pair.h:233:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator>(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/5.3.0/bits/stl_pair.h:233:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::pair<_T1, _T2>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:870:5: note: candidate: template<class _Iterator, class _Container> bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)
     operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:870:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const __gnu_cxx::__normal_iterator<_Iterator, _Container>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:64:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_pair.h:233:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator>(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/5.3.0/bits/stl_pair.h:233:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::pair<_T1, _T2>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:870:5: note: candidate: template<class _Iterator, class _Container> bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)
     operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:870:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const __gnu_cxx::__normal_iterator<_Iterator, _Container>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:863:5: note: candidate: template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)
     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:863:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const __gnu_cxx::__normal_iterator<_IteratorL, _Container>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:863:5: note: candidate: template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)
     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:863:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const __gnu_cxx::__normal_iterator<_IteratorL, _Container>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
/usr/include/boost/multiprecision/detail/default_ops.hpp: In instantiation of ‘bool boost::multiprecision::default_ops::check_in_range(const T&) [with R = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; T = long double]’:
/usr/include/boost/multiprecision/detail/default_ops.hpp:867:24:   required from ‘void boost::multiprecision::default_ops::eval_convert_to(R*, const B&) [with R = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; B = boost::multiprecision::backends::cpp_int_backend<>]’
/usr/include/boost/multiprecision/number.hpp:585:22:   required from ‘void boost::multiprecision::number<Backend, ExpressionTemplates>::convert_to_imp(T*) const [with T = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/usr/include/boost/multiprecision/number.hpp:601:21:   required from ‘T boost::multiprecision::number<Backend, ExpressionTemplates>::convert_to() const [with T = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/usr/include/boost/multiprecision/number.hpp:629:43:   required from ‘boost::multiprecision::number<Backend, ExpressionTemplates>::operator T() const [with T = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:54:61:   required from ‘std::vector<alcp::Fqelem<Integer> > alcp::Fq<Integer>::getElems() const [with Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:419:17:   required from ‘std::vector<Fxelem> alcp::berlekamp_simple(const Fxelem&) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:492:74:   required from here
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: error: no match for ‘operator>’ (operand types are ‘const long double’ and ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’)
/usr/include/boost/multiprecision/detail/default_ops.hpp: In instantiation of ‘bool boost::multiprecision::default_ops::check_in_range(const T&) [with R = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; T = long double]’:
/usr/include/boost/multiprecision/detail/default_ops.hpp:867:24:   required from ‘void boost::multiprecision::default_ops::eval_convert_to(R*, const B&) [with R = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; B = boost::multiprecision::backends::cpp_int_backend<>]’
/usr/include/boost/multiprecision/number.hpp:585:22:   required from ‘void boost::multiprecision::number<Backend, ExpressionTemplates>::convert_to_imp(T*) const [with T = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/usr/include/boost/multiprecision/number.hpp:601:21:   required from ‘T boost::multiprecision::number<Backend, ExpressionTemplates>::convert_to() const [with T = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/usr/include/boost/multiprecision/number.hpp:629:43:   required from ‘boost::multiprecision::number<Backend, ExpressionTemplates>::operator T() const [with T = std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = (boost::multiprecision::expression_template_option)1u]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:54:61:   required from ‘std::vector<alcp::Fqelem<Integer> > alcp::Fq<Integer>::getElems() const [with Integer = boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:419:17:   required from ‘std::vector<Fxelem> alcp::berlekamp_simple(const Fxelem&) [with Fxelem = alcp::Fqxelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >]’
/media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:492:74:   required from here
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: error: no match for ‘operator>’ (operand types are ‘const long double’ and ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’)
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:311:13: note: candidate: template<class Backend, boost::multiprecision::expression_template_option ExpressionTemplates, class Backend2, boost::multiprecision::expression_template_option ExpressionTemplates2> bool boost::multiprecision::operator>(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::number<T2, ExpressionTemplates2>&)
 inline bool operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
             ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:311:13: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:319:4: note: candidate: template<class Backend, boost::multiprecision::expression_template_option ExpressionTemplates, class Arithmetic> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<boost::multiprecision::number<Backend, ExpressionTemplates>, Val>::value, bool>::type boost::multiprecision::operator>(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const Arithmetic&)
    operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:319:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘const long double’
    if(std::numeric_liIn file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:311:13: note: candidate: template<class Backend, boost::multiprecision::expression_template_option ExpressionTemplates, class Backend2, boost::multiprecision::expression_template_option ExpressionTemplates2> bool boost::multiprecision::operator>(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::number<T2, ExpressionTemplates2>&)
 inline bool operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend2, ExpressionTemplates2>& b)
             ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:311:13: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:319:4: note: candidate: template<class Backend, boost::multiprecision::expression_template_option ExpressionTemplates, class Arithmetic> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<boost::multiprecision::number<Backend, ExpressionTemplates>, Val>::value, bool>::type boost::multiprecision::operator>(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const Arithmetic&)
    operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:319:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:327:4: note: candidate: template<class Arithmetic, class Backend, boost::multiprecision::expression_template_option ExpressionTemplates> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<boost::multiprecision::number<T2, ExpressionTemplates>, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const Arithmetic&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:327:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ is not derived from ‘const boost::multiprecision::number<T2, ExpressionTemplates>’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:335:4: note: candidate: template<class Arithmetic, class Tag, class A1, class A2, class A3, class A4> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const Arithmetic&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:335:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrivemits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:327:4: note: candidate: template<class Arithmetic, class Backend, boost::multiprecision::expression_template_option ExpressionTemplates> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<boost::multiprecision::number<T2, ExpressionTemplates>, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const Arithmetic&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:327:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ is not derived from ‘const boost::multiprecision::number<T2, ExpressionTemplates>’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:335:4: note: candidate: template<class Arithmetic, class Tag, class A1, class A2, class A3, class A4> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const Arithmetic&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:335:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:345:4: note: candidate: template<class Tag, class A1, class A2, class A3, class A4, class Arithmetic> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const Arithmetic&)
    operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:345:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:355:4: note: candidate: template<class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b> typename boost::enable_if<boost::is_same<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, typename boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type boost::multiprecision::operator>(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operat/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   ‘std::vector<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > >, std::allocator<alcp::Fqelem<boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> > > > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:345:4: note: candidate: template<class Tag, class A1, class A2, class A3, class A4, class Arithmetic> typename boost::enable_if_c<boost::multiprecision::detail::is_valid_mixed_compare<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, Arithmetic>::value, bool>::type boost::multiprecision::operator>(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const Arithmetic&)
    operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:345:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/boost/multiprecision/number.hpp:23:0,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/number_compare.hpp:355:4: note: candidate: template<class Tag, class A1, class A2, class A3, class A4, class Tagb, class A1b, class A2b, class A3b, class A4b> typename boost::enable_if<boost::is_same<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, typename boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>::result_type>, bool>::type boost::multiprecision::operator>(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:355:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/map:62:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:11,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/usr/include/c++/5.3.0/bits/stl_multimap.h:1005:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator>(const std::multimap<_Key, _Tp, _Compare, _Alloc>&, const std::multimap<_Key, _Tp, _Compare, _Alloc>&)
     operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_multimap.h:1005:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::multimap<_Key, _Tp, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/map:61:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:11,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/usr/include/c++/5.3.0/bits/stl_map.h:1104:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator>(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key, _Tp, _Compare, _Alloc>&)
     operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_map.h:1104:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebraor > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
    ^
/usr/include/boost/multiprecision/detail/number_compare.hpp:355:4: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/map:62:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:11,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/usr/include/c++/5.3.0/bits/stl_multimap.h:1005:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator>(const std::multimap<_Key, _Tp, _Compare, _Alloc>&, const std::multimap<_Key, _Tp, _Compare, _Alloc>&)
     operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_multimap.h:1005:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::multimap<_Key, _Tp, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/map:61:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqelem.hpp:11,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fqxelem.hpp:7,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:11:
/usr/include/c++/5.3.0/bits/stl_map.h:1104:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator>(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key, _Tp, _Compare, _Alloc>&)
     operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_map.h:1104:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::map<_Key, _Tp, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:62:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_multiset.h:856:5: note: candidate: template<class _Key, class _Compare, class _Alloc> bool std::operator>(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key, _Compare, _Alloc>&)
     operator>(const multiset<_Key,_Compare,_Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_multiset.h:856:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::multiset<_Key, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:61:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_set.h:873:5: note: candidate: template<class _Key, class _Compare, class _Alloc> bool std::operator>(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key, _Compare, _Alloc>&)
     operator>(const set<_Key, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_set.h:873:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::set<_Key, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
 Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::map<_Key, _Tp, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:62:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_multiset.h:856:5: note: candidate: template<class _Key, class _Compare, class _Alloc> bool std::operator>(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key, _Compare, _Alloc>&)
     operator>(const multiset<_Key,_Compare,_Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_multiset.h:856:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::multiset<_Key, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:61:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_set.h:873:5: note: candidate: template<class _Key, class _Compare, class _Alloc> bool std::operator>(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key, _Compare, _Alloc>&)
     operator>(const set<_Key, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_set.h:873:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::set<_Key, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/set:60:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_tree.h:1300:5: note: candidate: template<class _Key, class _Val, class _KeyOfValue, class _Compare, class _Alloc> bool std::operator>(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&, const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)
     operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_tree.h:1300:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:414:5: note: candidate: template<class _Tp> bool std::operator>(std::nullptr_t, const std::shared_ptr<_Tp1>&)
     operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:414:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_spIn file included from /usr/include/c++/5.3.0/set:60:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpelem.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:9,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/stl_tree.h:1300:5: note: candidate: template<class _Key, class _Val, class _KeyOfValue, class _Compare, class _Alloc> bool std::operator>(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&, const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)
     operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_tree.h:1300:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:414:5: note: candidate: template<class _Tp> bool std::operator>(std::nullptr_t, const std::shared_ptr<_Tp1>&)
     operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:414:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:409:5: note: candidate: template<class _Tp> bool std::operator>(const std::shared_ptr<_Tp1>&, std::nullptr_t)
     operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:409:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::shared_ptr<_Tp1>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:403:5: note: candidate: template<class _Tp1, class _Tp2> bool std::operator>(const std::shared_ptr<_Tp1>&, const std::shared_ptr<_Tp2>&)
     operator>(const shared_ptr<_Tp1>& __a,
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:403:5: note:   template argument deductiecialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:409:5: note: candidate: template<class _Tp> bool std::operator>(const std::shared_ptr<_Tp1>&, std::nullptr_t)
     operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:409:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::shared_ptr<_Tp1>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/memory:82:0,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr.h:403:5: note: candidate: template<class _Tp1, class _Tp2> bool std::operator>(const std::shared_ptr<_Tp1>&, const std::shared_ptr<_Tp2>&)
     operator>(const shared_ptr<_Tp1>& __a,
     ^
/usr/include/c++/5.3.0/bits/shared_ptr.h:403:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::shared_ptr<_Tp1>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1261:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)
     operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1261:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_hanon/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::shared_ptr<_Tp1>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1261:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)
     operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1261:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1256:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)
     operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1256:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__shared_ptr<_Tp, _Lp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1250:5: note: candidate: template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)
     operator>(const __shared_ptr<_Tp1, _Lp>& __a,
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1250:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdridling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1256:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)
     operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1256:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__shared_ptr<_Tp, _Lp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/shared_ptr.h:52:0,
                 from /usr/include/c++/5.3.0/memory:82,
                 from /usr/include/boost/config/no_tr1/memory.hpp:21,
                 from /usr/include/boost/smart_ptr/shared_ptr.hpp:23,
                 from /usr/include/boost/shared_ptr.hpp:17,
                 from /usr/include/boost/format/alt_sstream.hpp:21,
                 from /usr/include/boost/format/internals.hpp:23,
                 from /usr/include/boost/format.hpp:38,
                 from /usr/include/boost/math/policies/error_handling.hpp:31,
                 from /usr/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1250:5: note: candidate: template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> bool std::operator>(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)
     operator>(const __shared_ptr<_Tp1, _Lp>& __a,
     ^
/usr/include/c++/5.3.0/bits/shared_ptr_base.h:1250:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__shared_ptr<_Tp1, _Lp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:711:5: note: candidate: template<class _Tp, class _Dp> bool std::operator>(std::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)
     operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:711:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:705:5: note: candidate: template<class _Tp, class _Dp> bool std::operator>(const std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)
     operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:705:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
        ve/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__shared_ptr<_Tp1, _Lp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:711:5: note: candidate: template<class _Tp, class _Dp> bool std::operator>(std::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)
     operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:711:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   cannot convert ‘t’ (type ‘const long double’) to type ‘std::nullptr_t’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:705:5: note: candidate: template<class _Tp, class _Dp> bool std::operator>(const std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)
     operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:705:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:699:5: note: candidate: template<class _Tp, class _Dp, class _Up, class _Ep> bool std::operator>(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up, _Ep>&)
     operator>(const unique_ptr<_Tp, _Dp>& __x,
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:699:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/unique_ptr.h:37:0,
                 from /usr/include/c++/5.3.0/bits/locale_conv.h:41,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/tuple:947:5: note: candidate: template<class ... _TElements, class ... _UElements> constexpr bool std::operator>(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator>(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/5.3.0/tuple:947:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::tuple<_Elements ...>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/tuple:39:0,
                 from /usr/include/c++/5.3.0/bits/unique_ptr.h:37,
                 from /usr/include/c++/5.3.0/bits/locale_                                                                                  ^
In file included from /usr/include/c++/5.3.0/bits/locale_conv.h:41:0,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/bits/unique_ptr.h:699:5: note: candidate: template<class _Tp, class _Dp, class _Up, class _Ep> bool std::operator>(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up, _Ep>&)
     operator>(const unique_ptr<_Tp, _Dp>& __x,
     ^
/usr/include/c++/5.3.0/bits/unique_ptr.h:699:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/unique_ptr.h:37:0,
                 from /usr/include/c++/5.3.0/bits/locale_conv.h:41,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/tuple:947:5: note: candidate: template<class ... _TElements, class ... _UElements> constexpr bool std::operator>(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator>(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/5.3.0/tuple:947:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::tuple<_Elements ...>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/tuple:39:0,
                 from /usr/include/c++/5.3.0/bits/unique_ptr.h:37,
                 from /usr/include/c++/5.3.0/bits/locale_conv.h:41,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/array:258:5: note: candidate: template<class _Tp, long unsigned int _Nm> bool std::operator>(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/5.3.0/array:258:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::array<_Tp, _Nm>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5050:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator>(const _CharT* __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5050:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const _CharT*’ and ‘long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5038:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/includconv.h:41,
                 from /usr/include/c++/5.3.0/locale:43,
                 from /usr/include/c++/5.3.0/iomanip:43,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:10,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/c++/5.3.0/array:258:5: note: candidate: template<class _Tp, long unsigned int _Nm> bool std::operator>(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/5.3.0/array:258:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::array<_Tp, _Nm>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5050:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator>(const _CharT* __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5050:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const _CharT*’ and ‘long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5038:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5038:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5026:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5026:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:1541:5: note: candidate: template<class _Tp, class _Alloc> bool std::operator>(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/5.3.0/bits/stl_vector.h:1541:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/de/c++/5.3.0/bits/basic_string.h:5038:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/string:52:0,
                 from /usr/include/c++/5.3.0/random:40,
                 from /usr/include/c++/5.3.0/bits/stl_algo.h:66,
                 from /usr/include/c++/5.3.0/algorithm:62,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:4:
/usr/include/c++/5.3.0/bits/basic_string.h:5026:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator>(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/basic_string.h:5026:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/vector:64:0,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_vector.h:1541:5: note: candidate: template<class _Tp, class _Alloc> bool std::operator>(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/5.3.0/bits/stl_vector.h:1541:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::vector<_Tp, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:1119:5: note: candidate: template<class _Iterator> bool std::operator>(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator>(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:1119:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::move_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:1113:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator>(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator>(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:1113:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::move_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
efault_ops.hpp:850:90: note:   mismatched types ‘const std::vector<_Tp, _Alloc>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:1119:5: note: candidate: template<class _Iterator> bool std::operator>(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator>(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:1119:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::move_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:1113:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator>(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator>(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:1113:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::move_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:360:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator>(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator>(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:360:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::reverse_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:310:5: note: candidate: template<class _Iterator> bool std::operator>(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator>(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:310:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::reverse_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:64:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_pair.h:233:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator>(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/5.3.0/bits/stl_pair.h:233:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:360:5: note: candidate: template<class _IteratorL, class _IteratorR> bool std::operator>(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator>(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:360:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::reverse_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:310:5: note: candidate: template<class _Iterator> bool std::operator>(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator>(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:310:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::reverse_iterator<_Iterator>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:64:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_pair.h:233:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator>(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/5.3.0/bits/stl_pair.h:233:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::pair<_T1, _T2>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:870:5: note: candidate: template<class _Iterator, class _Container> bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)
     operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:870:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const __gnu_cxx::__normal_iterator<_Iterator, _Container>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:863:5: note: candidate: template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)
     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     ^
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const std::pair<_T1, _T2>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:870:5: note: candidate: template<class _Iterator, class _Container> bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)
     operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:870:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const __gnu_cxx::__normal_iterator<_Iterator, _Container>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
In file included from /usr/include/c++/5.3.0/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/5.3.0/vector:60,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:1:
/usr/include/c++/5.3.0/bits/stl_iterator.h:863:5: note: candidate: template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)
     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:863:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const __gnu_cxx::__normal_iterator<_IteratorL, _Container>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
/usr/include/c++/5.3.0/bits/stl_iterator.h:863:5: note:   template argument deduction/substitution failed:
In file included from /usr/include/boost/multiprecision/detail/generic_interconvert.hpp:9:0,
                 from /usr/include/boost/multiprecision/number.hpp:22,
                 from /usr/include/boost/multiprecision/cpp_int.hpp:12,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/types.hpp:4,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/fpxelem.hpp:8,
                 from /media/gdrive/Documentos/5º Mat-Info/Álgebra Computacional/alcp/src/factorizationFq.cpp:10:
/usr/include/boost/multiprecision/detail/default_ops.hpp:850:90: note:   mismatched types ‘const __gnu_cxx::__normal_iterator<_IteratorL, _Container>’ and ‘const long double’
    if(std::numeric_limits<R>::is_specialized && std::numeric_limits<R>::is_bounded && (t > (std::numeric_limits<R>::max)()))
                                                                                          ^
make[2]: *** [CMakeFiles/alcp.dir/src/factorizationFq.cpp.o] Error 1
make[2]: *** [CMakeFiles/alcp.dir/src/factorizationFq.cpp.o] Error 1
make[1]: *** [CMakeFiles/alcp.dir/all] Error 2
make[1]: *** [CMakeFiles/alcp.dir/all] Error 2
make: *** [all] Error 2
make: *** [all] Error 2
